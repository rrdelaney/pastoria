/**
 * @fileoverview Router Code Generator
 *
 * This script generates type-safe router configuration files by scanning TypeScript
 * source code for JSDoc annotations. It's part of the "Pastoria" routing framework.
 *
 * How it works:
 * 1. Scans all TypeScript files in the project for exported functions/classes
 * 2. Looks for JSDoc tags: @route, @resource, @appRoot, and @param
 * 3. Looks for exported classes that extend PastoriaRootContext for GraphQL context
 * 4. Generates files from templates:
 *    - js_resource.ts: Resource configuration for lazy loading
 *    - router.tsx: Client-side router with type-safe routes
 *    - app_root.ts: Re-export of the app root component (if @appRoot is found)
 *    - context.ts: Re-export of user's context class, or generate a default one
 *
 * Usage:
 * - Add @route <route-name> to functions to create routes
 * - Add @param <name> <type> to document route parameters
 * - Add @resource <resource-name> to exports for lazy loading
 * - Add @appRoot to a component to designate it as the application root wrapper
 * - Add @gqlContext to a class extending PastoriaRootContext to provide a custom GraphQL context
 * - Add @serverRoute to functions to add an express handler
 *
 * The generator automatically creates Zod schemas for route parameters based on
 * TypeScript types, enabling runtime validation and type safety.
 */

import {readFile} from 'node:fs/promises';
import * as path from 'node:path';
import pc from 'picocolors';
import {
  CodeBlockWriter,
  Project,
  SourceFile,
  Symbol,
  SyntaxKind,
  ts,
  TypeFlags,
} from 'ts-morph';
import {logInfo, logWarn} from './logger.js';

async function loadRouterTemplates(project: Project, filename: string) {
  async function loadSourceFile(fileName: string, templateFileName: string) {
    const template = await readFile(templateFileName, 'utf-8');
    const warningComment = `/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly. Instead, edit the template at ${path.basename(templateFileName)}.
 */

`;
    return project.createSourceFile(fileName, warningComment + template, {
      overwrite: true,
    });
  }

  const template = path.join(import.meta.dirname, '../templates', filename);
  const output = path.join('__generated__/router', filename);
  return loadSourceFile(output, template);
}

type RouterResource = {
  sourceFile: SourceFile;
  symbol: Symbol;
  queries: Map<string, string>;
  entryPoints: Map<string, string>;
};

type RouterRoute = {
  sourceFile: SourceFile;
  symbol: Symbol;
  params: Map<string, ts.Type>;
};

type ExportedSymbol = {
  sourceFile: SourceFile;
  symbol: Symbol;
};

export interface PastoriaMetadata {
  resources: Map<string, RouterResource>;
  routes: Map<string, RouterRoute>;
  serverHandlers: Map<string, ExportedSymbol>;
  appRoot: ExportedSymbol | null;
  gqlContext: ExportedSymbol | null;
}

// Regex to quickly check if a file contains any Pastoria JSDoc tags
export const PASTORIA_TAG_REGEX =
  /@(route|resource|appRoot|param|gqlContext|serverRoute)\b/;

function collectQueryParameters(
  project: Project,
  queries: string[],
): Map<string, ts.Type> {
  const vars = new Map<string, ts.Type>();

  for (const query of queries) {
    const variablesType = project
      .getSourceFile(`__generated__/queries/${query}.graphql.ts`)
      ?.getExportedDeclarations()
      .get(`${query}$variables`)
      ?.at(0)
      ?.getType();

    if (variablesType == null) continue;

    for (const property of variablesType.getProperties()) {
      // TODO: Detect conflicting types among properties declared.
      const propertyName = property.getName();
      const propertyType = property.getValueDeclaration()?.getType();

      if (propertyType) {
        vars.set(propertyName, propertyType.compilerType);
      }
    }
  }

  return vars;
}

function collectPastoriaMetadata(project: Project): PastoriaMetadata {
  const resources = new Map<string, RouterResource>();
  const routes = new Map<string, RouterRoute>();
  const serverHandlers = new Map<string, ExportedSymbol>();
  let appRoot: ExportedSymbol | null = null;
  let gqlContext: ExportedSymbol | null = null;

  function visitRouterNodes(sourceFile: SourceFile) {
    // Skip generated files
    if (sourceFile.getFilePath().includes('__generated__')) {
      return;
    }

    // Skip files that don't contain any Pastoria JSDoc tags
    const fileText = sourceFile.getFullText();
    if (!PASTORIA_TAG_REGEX.test(fileText)) {
      return;
    }

    sourceFile.getExportSymbols().forEach((symbol) => {
      let routerResource = null as [string, RouterResource] | null;
      let routerRoute = null as [string, RouterRoute] | null;
      const routeParams = new Map<string, ts.Type>();

      function visitJSDocTags(tag: ts.JSDoc | ts.JSDocTag) {
        if (ts.isJSDoc(tag)) {
          tag.tags?.forEach(visitJSDocTags);
        } else if (ts.isJSDocParameterTag(tag)) {
          const typeNode = tag.typeExpression?.type;
          const tc = project.getTypeChecker().compilerObject;

          const type =
            typeNode == null
              ? tc.getUnknownType()
              : tc.getTypeFromTypeNode(typeNode);

          routeParams.set(tag.name.getText(), type);
        } else if (typeof tag.comment === 'string') {
          switch (tag.tagName.getText()) {
            case 'route': {
              routerRoute = [
                tag.comment,
                {sourceFile, symbol, params: routeParams},
              ];
              break;
            }
            case 'resource': {
              routerResource = [
                tag.comment,
                {
                  sourceFile,
                  symbol,
                  queries: new Map(),
                  entryPoints: new Map(),
                },
              ];
              break;
            }
            case 'serverRoute': {
              serverHandlers.set(tag.comment, {sourceFile, symbol});
              break;
            }
          }
        } else {
          // Handle tags without comments (like @ExportedSymbol, @gqlContext)
          switch (tag.tagName.getText()) {
            case 'appRoot': {
              if (appRoot != null) {
                logWarn('Multiple @appRoot tags found. Using the first one.');
              } else {
                appRoot = {
                  sourceFile,
                  symbol,
                };
              }
              break;
            }
            case 'gqlContext': {
              // Check if this class extends PastoriaRootContext
              const declarations = symbol.getDeclarations();
              let extendsPastoriaRootContext = false;

              for (const decl of declarations) {
                if (decl.isKind(SyntaxKind.ClassDeclaration)) {
                  const classDecl = decl.asKindOrThrow(
                    SyntaxKind.ClassDeclaration,
                  );
                  const extendsClause = classDecl.getExtends();
                  if (extendsClause != null) {
                    const baseClassName = extendsClause
                      .getExpression()
                      .getText();
                    if (baseClassName === 'PastoriaRootContext') {
                      extendsPastoriaRootContext = true;
                      break;
                    }
                  }
                }
              }

              if (extendsPastoriaRootContext) {
                if (gqlContext != null) {
                  logWarn(
                    'Multiple classes with @gqlContext extending PastoriaRootContext found. Using the first one.',
                  );
                } else {
                  gqlContext = {
                    sourceFile,
                    symbol,
                  };
                }
              }
              break;
            }
          }
        }
      }

      symbol
        .getDeclarations()
        .flatMap((decl) => ts.getJSDocCommentsAndTags(decl.compilerNode))
        .forEach(visitJSDocTags);

      if (routerRoute != null) {
        const [routeName, routeSymbol] = routerRoute;
        routes.set(routeName, routeSymbol);

        const {entryPoints, queries} = getResourceQueriesAndEntryPoints(
          routeSymbol.symbol,
        );

        if (routerResource == null && (entryPoints.size || queries.size)) {
          resources.set(`route(${routeName})`, {
            ...routeSymbol,
            entryPoints,
            queries,
          });
        }
      }

      if (routerResource != null) {
        const [resourceName, resourceSymbol] = routerResource;
        const {entryPoints, queries} = getResourceQueriesAndEntryPoints(
          resourceSymbol.symbol,
        );

        resourceSymbol.queries = queries;
        resourceSymbol.entryPoints = entryPoints;
        resources.set(resourceName, resourceSymbol);
      }
    });
  }

  project.getSourceFiles().forEach(visitRouterNodes);
  return {resources, routes, appRoot, gqlContext, serverHandlers};
}

function getResourceQueriesAndEntryPoints(symbol: Symbol): {
  queries: Map<string, string>;
  entryPoints: Map<string, string>;
} {
  const resource = {
    queries: new Map<string, string>(),
    entryPoints: new Map<string, string>(),
  };

  const decl = symbol.getValueDeclaration();
  if (!decl) return resource;

  const t = decl.getType();
  const aliasSymbol = t.getAliasSymbol();

  if (aliasSymbol?.getName() === 'EntryPointComponent') {
    const [queries, entryPoints] = t.getAliasTypeArguments();

    queries?.getProperties().forEach((prop) => {
      const queryRef = prop.getName();
      const queryName = prop
        .getValueDeclaration()
        ?.getType()
        .getAliasSymbol()
        ?.getName();

      if (queryName) {
        resource.queries.set(queryRef, queryName);
      }
    });

    entryPoints?.getProperties().forEach((prop) => {
      const epRef = prop.getName();
      const entryPointTypeRef = prop
        .getValueDeclaration()
        ?.asKind(SyntaxKind.PropertySignature)
        ?.getTypeNode()
        ?.asKind(SyntaxKind.TypeReference);

      const entryPointTypeName = entryPointTypeRef?.getTypeName().getText();
      if (entryPointTypeName !== 'EntryPoint') {
        // TODO: Warn about found types not named EntryPoint
        return;
      }

      const entryPointInner = entryPointTypeRef?.getTypeArguments().at(0);
      const moduleTypeRef = entryPointInner?.asKind(SyntaxKind.TypeReference);
      if (moduleTypeRef != null) {
        const resourceName = moduleTypeRef
          ?.getTypeArguments()
          .at(0)
          ?.asKind(SyntaxKind.LiteralType)
          ?.getLiteral()
          .asKind(SyntaxKind.StringLiteral)
          ?.getLiteralText();

        if (resourceName) {
          resource.entryPoints.set(epRef, resourceName);
        }
      }
    });
  }

  return resource;
}

function zodSchemaOfType(
  sf: SourceFile,
  tc: ts.TypeChecker,
  t: ts.Type,
): string {
  if (t.aliasSymbol) {
    const decl = t.aliasSymbol.declarations?.at(0);
    if (decl == null) {
      logWarn('Could not handle type:', tc.typeToString(t));
      return `z.any()`;
    } else {
      const importPath = sf.getRelativePathAsModuleSpecifierTo(
        decl.getSourceFile().fileName,
      );

      return `z.transform((s: string) => s as import('${importPath}').${t.aliasSymbol.getName()})`;
    }
  } else if (t.getFlags() & TypeFlags.String) {
    return `z.pipe(z.string(), z.transform(decodeURIComponent))`;
  } else if (t.getFlags() & TypeFlags.Number) {
    return `z.coerce.number<number>()`;
  } else if (t.getFlags() & TypeFlags.Null) {
    return `z.preprocess(s => s == null ? undefined : s, z.undefined())`;
  } else if (t.isUnion()) {
    const nullishTypes: ts.Type[] = [];
    const nonNullishTypes: ts.Type[] = [];
    for (const s of t.types) {
      const flags = s.getFlags();
      if (flags & TypeFlags.Null || flags & TypeFlags.Undefined) {
        nullishTypes.push(s);
      } else {
        nonNullishTypes.push(s);
      }
    }

    if (nullishTypes.length > 0 && nonNullishTypes.length > 0) {
      const nonOptionalType = t.getNonNullableType();
      return `z.pipe(z.nullish(${zodSchemaOfType(sf, tc, nonOptionalType)}), z.transform(s => s == null ? undefined : s))`;
    } else {
      return `z.union([${t.types.map((it) => zodSchemaOfType(sf, tc, it)).join(', ')}])`;
    }
  } else if (tc.isArrayLikeType(t)) {
    const typeArg = tc.getTypeArguments(t as ts.TypeReference)[0];
    const argZodSchema =
      typeArg == null ? `z.any()` : zodSchemaOfType(sf, tc, typeArg);

    return `z.array(${argZodSchema})`;
  } else {
    logWarn('Could not handle type:', tc.typeToString(t));
    return `z.any()`;
  }
}

function writeEntryPoint(
  writer: CodeBlockWriter,
  project: Project,
  metadata: PastoriaMetadata,
  consumedQueries: Set<string>,
  resourceName: string,
  resource: RouterResource,
  parseVars = true,
) {
  writer.writeLine(`root: JSResource.fromModuleId('${resourceName}'),`);

  writer
    .write(`getPreloadProps(${parseVars ? '{params, schema}' : ''})`)
    .block(() => {
      if (parseVars) {
        writer.writeLine('const variables = schema.parse(params);');
      }

      writer.write('return').block(() => {
        writer
          .write('queries:')
          .block(() => {
            for (const [queryRef, query] of resource.queries.entries()) {
              consumedQueries.add(query);

              // Determine which variables this specific query needs
              const queryVars = collectQueryParameters(project, [query]);
              const hasVariables = queryVars.size > 0;

              writer
                .write(`${queryRef}:`)
                .block(() => {
                  writer.writeLine(`parameters: ${query}Parameters,`);

                  if (hasVariables) {
                    const varNames = Array.from(queryVars.keys());
                    // Always pick from the variables object
                    writer.write(`variables: {`);
                    writer.write(
                      varNames.map((v) => `${v}: variables.${v}`).join(', '),
                    );
                    writer.write(`}`);
                  } else {
                    // Query has no variables, pass empty object
                    writer.write(`variables: {}`);
                  }
                  writer.newLine();
                })
                .write(',');
            }
          })
          .writeLine(',');

        writer.write('entryPoints:').block(() => {
          for (const [
            epRef,
            subresourceName,
          ] of resource.entryPoints.entries()) {
            const subresource = metadata.resources.get(subresourceName);
            if (subresource) {
              writer
                .write(`${epRef}:`)
                .block(() => {
                  writer.writeLine(`entryPointParams: {},`);
                  writer.write('entryPoint:').block(() => {
                    writeEntryPoint(
                      writer,
                      project,
                      metadata,
                      consumedQueries,
                      subresourceName,
                      subresource,
                      false,
                    );
                  });
                })
                .writeLine(',');
            }
          }
        });
      });
    });
}

async function generateRouter(project: Project, metadata: PastoriaMetadata) {
  const routerTemplate = await loadRouterTemplates(project, 'router.tsx');
  const tc = project.getTypeChecker().compilerObject;

  let didAddJsResourceImport = false;
  const routerConf = routerTemplate
    .getVariableDeclarationOrThrow('ROUTER_CONF')
    .getInitializerIfKindOrThrow(SyntaxKind.AsExpression)
    .getExpressionIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

  routerConf.getPropertyOrThrow('noop').remove();

  let entryPointImportIndex = 0;
  for (let [
    routeName,
    {sourceFile, symbol, params},
  ] of metadata.routes.entries()) {
    const filePath = path.relative(process.cwd(), sourceFile.getFilePath());
    let entryPointExpression: string;

    // Resource-routes are combined declarations of a resource and a route
    // where we should generate the entrypoint for the route.
    const isResourceRoute = Array.from(metadata.resources.entries()).find(
      ([, {symbol: resourceSymbol}]) => symbol === resourceSymbol,
    );

    if (isResourceRoute) {
      const [resourceName, resource] = isResourceRoute;
      const entryPointFunctionName = `entrypoint_${resourceName.replace(/\W/g, '')}`;

      if (!didAddJsResourceImport) {
        didAddJsResourceImport = true;
        routerTemplate.addImportDeclaration({
          moduleSpecifier: './js_resource',
          namedImports: ['JSResource', 'ModuleType'],
        });
      }

      const consumedQueries = new Set<string>();
      routerTemplate.addFunction({
        name: entryPointFunctionName,
        returnType: `EntryPoint<ModuleType<'${resourceName}'>, EntryPointParams<'${routeName}'>>`,
        statements: (writer) => {
          writer.write('return ').block(() => {
            writeEntryPoint(
              writer,
              project,
              metadata,
              consumedQueries,
              resourceName,
              resource,
            );
          });
        },
      });

      if (params.size === 0 && consumedQueries.size > 0) {
        params = collectQueryParameters(project, Array.from(consumedQueries));
      }

      for (const query of consumedQueries) {
        routerTemplate.addImportDeclaration({
          moduleSpecifier: `#genfiles/queries/${query}$parameters`,
          defaultImport: `${query}Parameters`,
        });
      }

      entryPointExpression = entryPointFunctionName + '()';
    } else {
      const importAlias = `e${entryPointImportIndex++}`;
      const moduleSpecifier = routerTemplate.getRelativePathAsModuleSpecifierTo(
        sourceFile.getFilePath(),
      );

      routerTemplate.addImportDeclaration({
        moduleSpecifier,
        namedImports: [
          {
            name: symbol.getName(),
            alias: importAlias,
          },
        ],
      });

      entryPointExpression = importAlias;
    }

    routerConf.addPropertyAssignment({
      name: `"${routeName}"`,
      initializer: (writer) => {
        writer
          .write('{')
          .indent(() => {
            writer.writeLine(`entrypoint: ${entryPointExpression},`);
            if (params.size === 0) {
              writer.writeLine(`schema: z.object({})`);
            } else {
              writer.writeLine(`schema: z.object({`);
              for (const [paramName, paramType] of Array.from(params)) {
                writer.writeLine(
                  `  ${paramName}: ${zodSchemaOfType(routerTemplate, tc, paramType)},`,
                );
              }

              writer.writeLine('})');
            }
          })
          .write('} as const');
      },
    });

    logInfo(
      'Created route',
      pc.cyan(routeName),
      'for',
      pc.green(symbol.getName()),
      'exported from',
      pc.yellow(filePath),
    );
  }

  await routerTemplate.save();
}

async function generateJsResource(
  project: Project,
  metadata: PastoriaMetadata,
) {
  const jsResourceTemplate = await loadRouterTemplates(
    project,
    'js_resource.ts',
  );

  const resourceConf = jsResourceTemplate
    .getVariableDeclarationOrThrow('RESOURCE_CONF')
    .getInitializerIfKindOrThrow(SyntaxKind.AsExpression)
    .getExpressionIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

  resourceConf.getPropertyOrThrow('noop').remove();
  for (const [
    resourceName,
    {sourceFile, symbol},
  ] of metadata.resources.entries()) {
    const filePath = path.relative(process.cwd(), sourceFile.getFilePath());
    const moduleSpecifier =
      jsResourceTemplate.getRelativePathAsModuleSpecifierTo(
        sourceFile.getFilePath(),
      );

    resourceConf.addPropertyAssignment({
      name: `"${resourceName}"`,
      initializer: (writer) => {
        writer.block(() => {
          writer
            .writeLine(`src: "${filePath}",`)
            .writeLine(
              `loader: () => import("${moduleSpecifier}").then(m => m.${symbol.getName()})`,
            );
        });
      },
    });

    logInfo(
      'Created resource',
      pc.cyan(resourceName),
      'for',
      pc.green(symbol.getName()),
      'exported from',
      pc.yellow(filePath),
    );
  }

  await jsResourceTemplate.save();
}

async function generateAppRoot(project: Project, metadata: PastoriaMetadata) {
  const targetDir = process.cwd();
  const appRoot: ExportedSymbol | null = metadata.appRoot;

  if (appRoot == null) {
    await project
      .getSourceFile('__generated__/router/app_root.ts')
      ?.deleteImmediately();

    return;
  }

  const appRootSourceFile: SourceFile = appRoot.sourceFile;
  const appRootSymbol: Symbol = appRoot.symbol;
  const filePath = path.relative(targetDir, appRootSourceFile.getFilePath());
  const appRootFile = project.createSourceFile(
    '__generated__/router/app_root.ts',
    '',
    {overwrite: true},
  );

  const moduleSpecifier = appRootFile.getRelativePathAsModuleSpecifierTo(
    appRootSourceFile.getFilePath(),
  );

  appRootFile.addStatements(`/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 */

export {${appRootSymbol.getName()} as App} from '${moduleSpecifier}';
`);

  await appRootFile.save();

  logInfo(
    'Created app root for',
    pc.green(appRootSymbol.getName()),
    'exported from',
    pc.yellow(filePath),
  );
}

async function generateGraphqlContext(
  project: Project,
  metadata: PastoriaMetadata,
) {
  const targetDir = process.cwd();
  const gqlContext: ExportedSymbol | null = metadata.gqlContext;
  const contextFile = project.createSourceFile(
    '__generated__/router/context.ts',
    '',
    {overwrite: true},
  );

  if (gqlContext != null) {
    const contextSourceFile: SourceFile = gqlContext.sourceFile;
    const contextSymbol: Symbol = gqlContext.symbol;
    const filePath = path.relative(targetDir, contextSourceFile.getFilePath());
    const moduleSpecifier = contextFile.getRelativePathAsModuleSpecifierTo(
      contextSourceFile.getFilePath(),
    );

    contextFile.addStatements(`/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 */

export {${contextSymbol.getName()} as Context} from '${moduleSpecifier}';
`);

    logInfo(
      'Created GraphQL context for',
      pc.green(contextSymbol.getName()),
      'exported from',
      pc.yellow(filePath),
    );
  } else {
    contextFile.addStatements(`/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 */

import {PastoriaRootContext} from 'pastoria-runtime/server';

/**
 * @gqlContext
 */
export class Context extends PastoriaRootContext {}
`);

    logInfo('No @gqlContext found, generating default', pc.green('Context'));
  }

  await contextFile.save();
}

async function generateServerHandler(
  project: Project,
  metadata: PastoriaMetadata,
) {
  if (metadata.serverHandlers.size === 0) {
    await project
      .getSourceFile('__generated__/router/server_handler.ts')
      ?.deleteImmediately();

    return;
  }

  const sourceText = `import express from 'express';
export const router = express.Router();
`;

  const serverHandlerTemplate = project.createSourceFile(
    '__generated__/router/server_handler.ts',
    sourceText,
    {overwrite: true},
  );

  let serverHandlerImportIndex = 0;
  for (const [
    routeName,
    {symbol, sourceFile},
  ] of metadata.serverHandlers.entries()) {
    const importAlias = `e${serverHandlerImportIndex++}`;
    const filePath = path.relative(process.cwd(), sourceFile.getFilePath());
    const moduleSpecifier =
      serverHandlerTemplate.getRelativePathAsModuleSpecifierTo(
        sourceFile.getFilePath(),
      );

    serverHandlerTemplate.addImportDeclaration({
      moduleSpecifier,
      namedImports: [{name: symbol.getName(), alias: importAlias}],
    });

    serverHandlerTemplate.addStatements(
      `router.use('${routeName}', ${importAlias})`,
    );

    logInfo(
      'Created server handler',
      pc.cyan(routeName),
      'for',
      pc.green(symbol.getName()),
      'exported from',
      pc.yellow(filePath),
    );
  }

  await serverHandlerTemplate.save();
}

export async function generatePastoriaExports(project: Project) {
  const metadata = collectPastoriaMetadata(project);

  await generateAppRoot(project, metadata);
  await generateGraphqlContext(project, metadata);
  return metadata;
}

export async function generatePastoriaArtifacts(
  project: Project,
  metadata = collectPastoriaMetadata(project),
) {
  await generateRouter(project, metadata);
  await generateJsResource(project, metadata);
  await generateServerHandler(project, metadata);
}

export interface PastoriaCapabilities {
  hasAppRoot: boolean;
  hasServerHandler: boolean;
}

export function generateClientEntry({
  hasAppRoot,
}: PastoriaCapabilities): string {
  const appImport = hasAppRoot
    ? `import {App} from '#genfiles/router/app_root';`
    : '';
  const appValue = hasAppRoot ? 'App' : 'null';

  return `// Generated by Pastoria.
import {createRouterApp} from '#genfiles/router/router';
${appImport}
import {hydrateRoot} from 'react-dom/client';

async function main() {
  const RouterApp = await createRouterApp();
  hydrateRoot(document, <RouterApp App={${appValue}} />);
}

main();
`;
}

export function generateServerEntry({
  hasAppRoot,
  hasServerHandler,
}: PastoriaCapabilities): string {
  const appImport = hasAppRoot
    ? `import {App} from '#genfiles/router/app_root';`
    : '';
  const appValue = hasAppRoot ? 'App' : 'null';

  const serverHandlerImport = hasServerHandler
    ? `import {router as serverHandler} from '#genfiles/router/server_handler';`
    : '';
  const serverHandlerUse = hasServerHandler
    ? '  router.use(serverHandler)'
    : '';

  return `// Generated by Pastoria.
import {JSResource} from '#genfiles/router/js_resource';
import {
  listRoutes,
  router__createAppFromEntryPoint,
  router__loadEntryPoint,
} from '#genfiles/router/router';
import {getSchema} from '#genfiles/schema/schema';
import {Context} from '#genfiles/router/context';
${appImport}
${serverHandlerImport}
import express from 'express';
import {GraphQLSchema, specifiedDirectives} from 'graphql';
import {PastoriaConfig} from 'pastoria-config';
import {createRouterHandler} from 'pastoria-runtime/server';
import type {Manifest} from 'vite';

const schemaConfig = getSchema().toConfig();
const schema = new GraphQLSchema({
  ...schemaConfig,
  directives: [...specifiedDirectives, ...schemaConfig.directives],
});

export function createHandler(
  persistedQueries: Record<string, string>,
  config: Required<PastoriaConfig>,
  manifest?: Manifest,
) {
  const routeHandler = createRouterHandler(
    listRoutes(),
    JSResource.srcOfModuleId,
    router__loadEntryPoint,
    router__createAppFromEntryPoint,
    ${appValue},
    schema,
    (req) => Context.createFromRequest(req),
    persistedQueries,
    config,
    manifest,
  );

  const router = express.Router();
  router.use(routeHandler);
  ${serverHandlerUse}

  return router;
}
`;
}
