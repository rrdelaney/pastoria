/**
 * @fileoverview Router Code Generator
 *
 * This script generates type-safe router configuration files using filesystem-based
 * routing, similar to Next.js App Router.
 *
 * ## Filesystem Routing Convention
 *
 * Routes are defined by the directory structure under `pastoria/`:
 * - `pastoria/page.tsx` → Route `/`
 * - `pastoria/about/page.tsx` → Route `/about`
 * - `pastoria/post/[slug]/page.tsx` → Route `/post/:slug`
 * - `pastoria/app.tsx` → Root layout component
 * - `pastoria/api/.../route.ts` → API route handlers
 * - `pastoria/*.page.tsx` → Nested entry points
 * - `pastoria/entrypoint.ts` → Manual entry point definitions
 *
 * ## Page Files
 *
 * Each `page.tsx` should:
 * - Default export a React component
 * - Optionally export `queries` object mapping query refs to Relay query types
 *
 * ## Generated Files
 *
 * Output is placed in `__generated__/router/`:
 * - `js_resource.ts` - Resource configuration for lazy loading
 * - `router.tsx` - Client-side router with type-safe routes
 * - `app_root.ts` - Re-export of the app root component
 * - `environment.ts` - Re-export of the user's PastoriaEnvironment
 * - `server_handler.ts` - API route handlers
 * - `types.ts` - PageProps and other type definitions
 */

import {readFile} from 'node:fs/promises';
import * as path from 'node:path';
import pc from 'picocolors';
import {
  CodeBlockWriter,
  Project,
  SourceFile,
  SyntaxKind,
  ts,
  TypeFlags,
} from 'ts-morph';
import {
  type FilesystemMetadata,
  type FilesystemPage,
  scanFilesystemRoutes,
  toRouterPath,
} from './filesystem.js';
import {logInfo, logWarn} from './logger.js';

// ============================================================================
// Template Loading
// ============================================================================

/**
 * Loads a template file and creates a new source file with a generated header.
 */
async function loadRouterTemplate(project: Project, filename: string) {
  const templatePath = path.join(import.meta.dirname, '../templates', filename);
  const outputPath = path.join('__generated__/router', filename);

  const template = await readFile(templatePath, 'utf-8');
  const warningComment = `/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 */

`;

  return project.createSourceFile(outputPath, warningComment + template, {
    overwrite: true,
  });
}

// ============================================================================
// Query Parameter Collection
// ============================================================================

/**
 * Collects query variables from Relay-generated query type files.
 *
 * For each query, looks up the generated `${queryName}$variables` type
 * and extracts all property names and types.
 */
function collectQueryParameters(
  project: Project,
  queries: string[],
): Map<string, ts.Type> {
  const vars = new Map<string, ts.Type>();

  for (const query of queries) {
    // Find the generated query file
    const queryFile = project.getSourceFile(
      `__generated__/queries/${query}.graphql.ts`,
    );

    if (!queryFile) continue;

    // Get the variables type export
    const variablesType = queryFile
      .getExportedDeclarations()
      .get(`${query}$variables`)
      ?.at(0)
      ?.getType();

    if (!variablesType) continue;

    // Extract each property from the variables type
    for (const property of variablesType.getProperties()) {
      const propertyName = property.getName();
      const propertyType = property.getValueDeclaration()?.getType();

      if (propertyType) {
        vars.set(propertyName, propertyType.compilerType);
      }
    }
  }

  return vars;
}

// ============================================================================
// Zod Schema Generation
// ============================================================================

/**
 * Generates a Zod schema string for a TypeScript type.
 *
 * Used to create runtime validation schemas for route parameters.
 */
function zodSchemaOfType(
  sf: SourceFile,
  tc: ts.TypeChecker,
  t: ts.Type,
): string {
  // Handle type aliases (custom types)
  if (t.aliasSymbol) {
    const decl = t.aliasSymbol.declarations?.at(0);
    if (decl == null) {
      logWarn('Could not handle type:', tc.typeToString(t));
      return `z.any()`;
    } else {
      const importPath = sf.getRelativePathAsModuleSpecifierTo(
        decl.getSourceFile().fileName,
      );
      return `z.transform((s: string) => s as import('${importPath}').${t.aliasSymbol.getName()})`;
    }
  }

  // Handle primitive types
  if (t.getFlags() & TypeFlags.String) {
    return `z.pipe(z.string(), z.transform(decodeURIComponent))`;
  }

  if (t.getFlags() & TypeFlags.Number) {
    return `z.coerce.number<number>()`;
  }

  if (t.getFlags() & TypeFlags.Null) {
    return `z.preprocess(s => s == null ? undefined : s, z.undefined())`;
  }

  // Handle union types
  if (t.isUnion()) {
    const nullishTypes: ts.Type[] = [];
    const nonNullishTypes: ts.Type[] = [];

    for (const s of t.types) {
      const flags = s.getFlags();
      if (flags & TypeFlags.Null || flags & TypeFlags.Undefined) {
        nullishTypes.push(s);
      } else {
        nonNullishTypes.push(s);
      }
    }

    if (nullishTypes.length > 0 && nonNullishTypes.length > 0) {
      const nonOptionalType = t.getNonNullableType();
      return `z.pipe(z.nullish(${zodSchemaOfType(sf, tc, nonOptionalType)}), z.transform(s => s == null ? undefined : s))`;
    } else {
      return `z.union([${t.types.map((it) => zodSchemaOfType(sf, tc, it)).join(', ')}])`;
    }
  }

  // Handle array types
  if (tc.isArrayLikeType(t)) {
    const typeArg = tc.getTypeArguments(t as ts.TypeReference)[0];
    const argZodSchema =
      typeArg == null ? `z.any()` : zodSchemaOfType(sf, tc, typeArg);
    return `z.array(${argZodSchema})`;
  }

  // Fallback
  logWarn('Could not handle type:', tc.typeToString(t));
  return `z.any()`;
}

// ============================================================================
// Entry Point Generation
// ============================================================================

/**
 * Collects all query names from a page and its nested entry points.
 */
function collectAllQueries(page: FilesystemPage): Set<string> {
  const queries = new Set<string>();

  // Add main page queries
  for (const queryName of page.queries.values()) {
    queries.add(queryName);
  }

  // Add nested entry point queries
  for (const nestedPage of page.nestedEntryPoints.values()) {
    for (const queryName of nestedPage.queries.values()) {
      queries.add(queryName);
    }
  }

  return queries;
}

/**
 * Writes an entry point definition for a filesystem-based page.
 *
 * Generates a getPreloadProps function that:
 * 1. Parses route parameters using the captured Zod schema
 * 2. Sets up query preloading with the parsed variables
 * 3. Includes any nested entry points
 */
function writeFilesystemEntryPoint(
  writer: CodeBlockWriter,
  project: Project,
  page: FilesystemPage,
  resourceName: string,
  schemaExpression: string,
) {
  // Capture the schema in the closure
  writer.writeLine(`const schema = ${schemaExpression};`);
  writer.blankLine();

  // Write getPreloadProps as a named function
  const hasQueries = page.queries.size > 0;
  const hasNestedEntryPoints = page.nestedEntryPoints.size > 0;

  writer
    .write('function getPreloadProps({params}: {params: Record<string, any>})')
    .block(() => {
      // Parse params using the captured schema
      writer.writeLine('const variables = schema.parse(params);');

      writer.write('return').block(() => {
        // Write queries object
        writer.write('queries:').block(() => {
          for (const [queryRef, queryName] of page.queries.entries()) {
            // Collect variables needed by this specific query
            const queryVars = collectQueryParameters(project, [queryName]);
            const hasVariables = queryVars.size > 0;

            writer.write(`${queryRef}:`).block(() => {
              writer.writeLine(`parameters: ${queryName}Parameters,`);

              if (hasVariables) {
                const varNames = Array.from(queryVars.keys());
                writer.write('variables: {');
                writer.write(
                  varNames.map((v) => `${v}: variables.${v}`).join(', '),
                );
                writer.write('}');
              } else {
                writer.write('variables: {}');
              }
              writer.newLine();
            });
            writer.write(',');
          }
        });
        writer.writeLine(',');

        // Write nested entry points (undefined if none)
        if (hasNestedEntryPoints) {
          writer.write('entryPoints:').block(() => {
            for (const [
              epName,
              nestedPage,
            ] of page.nestedEntryPoints.entries()) {
              const nestedResourceName = `${resourceName}#${epName}`;

              writer.write(`${epName}:`).block(() => {
                writer.writeLine('entryPointParams: {},');
                writer.write('entryPoint:').block(() => {
                  // Write nested entry point (without param parsing)
                  writer.writeLine(
                    `root: JSResource.fromModuleId('${nestedResourceName}'),`,
                  );
                  writer.write('getPreloadProps()').block(() => {
                    writer.write('return').block(() => {
                      writer.write('queries:').block(() => {
                        for (const [
                          nestedQueryRef,
                          nestedQueryName,
                        ] of nestedPage.queries.entries()) {
                          // Collect variables needed by this nested query
                          const nestedQueryVars = collectQueryParameters(
                            project,
                            [nestedQueryName],
                          );
                          const hasNestedVariables = nestedQueryVars.size > 0;

                          writer.write(`${nestedQueryRef}:`).block(() => {
                            writer.writeLine(
                              `parameters: ${nestedQueryName}Parameters,`,
                            );

                            if (hasNestedVariables) {
                              const varNames = Array.from(
                                nestedQueryVars.keys(),
                              );
                              writer.write('variables: {');
                              writer.write(
                                varNames
                                  .map((v) => `${v}: variables.${v}`)
                                  .join(', '),
                              );
                              writer.write('}');
                            } else {
                              writer.write('variables: {}');
                            }
                            writer.newLine();
                          });
                          writer.write(',');
                        }
                      });
                      writer.writeLine(',');
                      // Nested entry points don't have further nesting
                      writer.writeLine('entryPoints: undefined');
                    });
                  });
                });
              });
              writer.writeLine(',');
            }
          });
        } else {
          writer.writeLine('entryPoints: undefined');
        }
      });
    });
}

// ============================================================================
// Router Generation
// ============================================================================

/**
 * Generates the router.tsx file with all route configurations.
 *
 * For each page discovered in the filesystem:
 * 1. Generates an entry point function with getPreloadProps
 * 2. Creates a route configuration entry with Zod schema
 */
async function generateRouter(
  project: Project,
  fsMetadata: FilesystemMetadata,
) {
  const routerTemplate = await loadRouterTemplate(project, 'router.tsx');

  // Get the ROUTER_CONF object to add routes to
  const routerConf = routerTemplate
    .getVariableDeclarationOrThrow('ROUTER_CONF')
    .getInitializerIfKindOrThrow(SyntaxKind.AsExpression)
    .getExpressionIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

  // Only remove the noop placeholder if there are actual routes
  // (keeping it prevents type errors when the config is empty)
  const hasRoutes =
    fsMetadata.pages.size > 0 || fsMetadata.entryPoints.size > 0;
  if (hasRoutes) {
    routerConf.getPropertyOrThrow('noop').remove();
  }

  // Add JSResource import
  routerTemplate.addImportDeclaration({
    moduleSpecifier: './js_resource',
    namedImports: ['JSResource', 'ModuleType'],
  });

  const tc = project.getTypeChecker().compilerObject;

  // Process each page
  for (const [routePath, page] of fsMetadata.pages.entries()) {
    // Convert [param] to :param for the router
    const routerPath = toRouterPath(routePath);

    // Create a unique resource name for this page
    const resourceName = `fs:page(${routePath})`;
    const safeResourceName = resourceName.replace(/[^a-zA-Z0-9]/g, '_');

    // Collect all queries consumed by this page and its nested entry points
    const consumedQueries = collectAllQueries(page);

    // Add imports for query parameters
    for (const queryName of consumedQueries) {
      routerTemplate.addImportDeclaration({
        moduleSpecifier: `#genfiles/queries/${queryName}$parameters`,
        defaultImport: `${queryName}Parameters`,
      });
    }

    // Build params schema from route params + query variables
    const params = new Map<string, ts.Type>();

    // Add filesystem params as string types
    for (const paramName of page.params) {
      params.set(paramName, tc.getStringType());
    }

    // Also include query variables
    if (consumedQueries.size > 0) {
      const queryParams = collectQueryParameters(
        project,
        Array.from(consumedQueries),
      );
      // Merge query params with route params (route params take precedence)
      for (const [paramName, paramType] of queryParams) {
        if (!params.has(paramName)) {
          params.set(paramName, paramType);
        }
      }
    }

    // Build schema expression string for the entry point to capture
    let schemaExpression: string;
    if (params.size === 0) {
      schemaExpression = 'z.object({})';
    } else {
      const schemaFields = Array.from(params.entries())
        .map(
          ([paramName, paramType]) =>
            `${paramName}: ${zodSchemaOfType(routerTemplate, tc, paramType)}`,
        )
        .join(', ');
      schemaExpression = `z.object({ ${schemaFields} })`;
    }

    // Generate the entry point function (captures schema in closure)
    routerTemplate.addFunction({
      name: `entrypoint_${safeResourceName}`,
      returnType: `EntryPoint<ModuleType<'${resourceName}'>, EntryPointParams<'${routerPath}'>>`,
      statements: (writer) => {
        writeFilesystemEntryPoint(
          writer,
          project,
          page,
          resourceName,
          schemaExpression,
        );
        writer.write('return ').block(() => {
          writer.writeLine(`root: JSResource.fromModuleId('${resourceName}'),`);
          writer.writeLine('getPreloadProps,');
        });
      },
    });

    // Add route configuration (uses :param format for radix3 router)
    routerConf.addPropertyAssignment({
      name: `"${routerPath}"`,
      initializer: (writer) => {
        writer.write('{').indent(() => {
          writer.writeLine(`entrypoint: entrypoint_${safeResourceName}(),`);
          writer.writeLine(`schema: ${schemaExpression}`);
        });
        writer.write('} as const');
      },
    });

    logInfo(
      'Created route',
      pc.cyan(routePath),
      'from',
      pc.yellow(page.filePath),
    );
  }

  // Process manual entry points (entrypoint.ts files)
  for (const [routePath, entryPoint] of fsMetadata.entryPoints.entries()) {
    // Convert [param] to :param for the router
    const routerPath = toRouterPath(routePath);
    const importAlias = `ep_${routePath.replace(/[^a-zA-Z0-9]/g, '_')}`;

    routerTemplate.addImportDeclaration({
      moduleSpecifier: routerTemplate.getRelativePathAsModuleSpecifierTo(
        path.join(process.cwd(), entryPoint.filePath),
      ),
      defaultImport: importAlias,
    });

    // Generate schema from params
    const params = new Map<string, ts.Type>();
    for (const paramName of entryPoint.params) {
      params.set(paramName, tc.getStringType());
    }

    routerConf.addPropertyAssignment({
      name: `"${routerPath}"`,
      initializer: (writer) => {
        writer.write('{').indent(() => {
          writer.writeLine(`entrypoint: ${importAlias},`);

          if (params.size === 0) {
            writer.writeLine('schema: z.object({})');
          } else {
            writer.writeLine('schema: z.object({');
            for (const [paramName, paramType] of params) {
              writer.writeLine(
                `  ${paramName}: ${zodSchemaOfType(routerTemplate, tc, paramType)},`,
              );
            }
            writer.writeLine('})');
          }
        });
        writer.write('} as const');
      },
    });

    logInfo(
      'Created manual entry point',
      pc.cyan(routePath),
      'from',
      pc.yellow(entryPoint.filePath),
    );
  }

  await routerTemplate.save();
}

// ============================================================================
// JS Resource Generation
// ============================================================================

/**
 * Generates the js_resource.ts file for lazy loading.
 *
 * Each page.tsx and *.page.tsx file becomes a lazy-loadable resource.
 */
async function generateJsResource(
  project: Project,
  fsMetadata: FilesystemMetadata,
) {
  const jsResourceTemplate = await loadRouterTemplate(
    project,
    'js_resource.ts',
  );

  const resourceConf = jsResourceTemplate
    .getVariableDeclarationOrThrow('RESOURCE_CONF')
    .getInitializerIfKindOrThrow(SyntaxKind.AsExpression)
    .getExpressionIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

  // Only remove the noop placeholder if there are actual pages
  const hasPages = fsMetadata.pages.size > 0;
  if (hasPages) {
    resourceConf.getPropertyOrThrow('noop').remove();
  }

  // Process main pages
  for (const [routePath, page] of fsMetadata.pages.entries()) {
    const resourceName = `fs:page(${routePath})`;
    const moduleSpecifier =
      jsResourceTemplate.getRelativePathAsModuleSpecifierTo(
        path.join(process.cwd(), page.filePath),
      );

    resourceConf.addPropertyAssignment({
      name: `"${resourceName}"`,
      initializer: (writer) => {
        writer.block(() => {
          writer.writeLine(`src: "${page.filePath}",`);
          writer.writeLine(
            `loader: (): Promise<ComponentType<PageProps<'${routePath}'>>> => import("${moduleSpecifier}").then(m => m.default)`,
          );
        });
      },
    });

    logInfo(
      'Created resource',
      pc.cyan(resourceName),
      'from',
      pc.yellow(page.filePath),
    );

    // Process nested entry points for this page
    for (const [epName, nestedPage] of page.nestedEntryPoints.entries()) {
      const nestedResourceName = `${resourceName}#${epName}`;
      const nestedModuleSpecifier =
        jsResourceTemplate.getRelativePathAsModuleSpecifierTo(
          path.join(process.cwd(), nestedPage.filePath),
        );

      // Nested entry points use flattened keys like '/#search_results'
      const nestedRouteKey = `${routePath}#${epName}`;
      resourceConf.addPropertyAssignment({
        name: `"${nestedResourceName}"`,
        initializer: (writer) => {
          writer.block(() => {
            writer.writeLine(`src: "${nestedPage.filePath}",`);
            writer.writeLine(
              `loader: (): Promise<ComponentType<PageProps<'${nestedRouteKey}'>>> => import("${nestedModuleSpecifier}").then(m => m.default)`,
            );
          });
        },
      });

      logInfo(
        'Created nested resource',
        pc.cyan(nestedResourceName),
        'from',
        pc.yellow(nestedPage.filePath),
      );
    }
  }

  await jsResourceTemplate.save();
}

// ============================================================================
// Server Handler Generation
// ============================================================================

/**
 * Generates server_handler.ts with API route handlers.
 *
 * Each route.ts file in the filesystem exports an express.Router
 * that handles requests at that path.
 */
async function generateServerHandler(
  project: Project,
  fsMetadata: FilesystemMetadata,
) {
  if (fsMetadata.apiRoutes.size === 0) {
    // No API routes found, delete the file if it exists
    await project
      .getSourceFile('__generated__/router/server_handler.ts')
      ?.deleteImmediately();
    return;
  }

  const serverHandlerFile = project.createSourceFile(
    '__generated__/router/server_handler.ts',
    `/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 */

import express from 'express';
export const router = express.Router();
`,
    {overwrite: true},
  );

  let importIndex = 0;
  for (const [routePath, apiRoute] of fsMetadata.apiRoutes.entries()) {
    // Convert [param] to :param for Express router
    const routerPath = toRouterPath(routePath);
    const importAlias = `route${importIndex++}`;
    const moduleSpecifier =
      serverHandlerFile.getRelativePathAsModuleSpecifierTo(
        path.join(process.cwd(), apiRoute.filePath),
      );

    serverHandlerFile.addImportDeclaration({
      moduleSpecifier,
      defaultImport: importAlias,
    });

    serverHandlerFile.addStatements(
      `router.use('${routerPath}', ${importAlias});`,
    );

    logInfo(
      'Created API route',
      pc.cyan(routePath),
      'from',
      pc.yellow(apiRoute.filePath),
    );
  }

  await serverHandlerFile.save();
}

// ============================================================================
// Type Generation
// ============================================================================

/**
 * Generates types.ts with PageProps type definitions.
 *
 * Creates types like PageProps<'/posts'> that include:
 * - queries: Preloaded query references
 * - entryPoints: Nested entry point references
 */
async function generateTypes(project: Project, fsMetadata: FilesystemMetadata) {
  const typesFile = project.createSourceFile(
    '__generated__/router/types.ts',
    '',
    {overwrite: true},
  );

  // Collect all query types to import
  const queryImports = new Set<string>();

  // Helper to build queries type string
  function buildQueriesType(queries: Map<string, string>): string {
    if (queries.size === 0) return '{}';
    return `{ ${Array.from(queries.entries())
      .map(([ref, queryTypeName]) => {
        queryImports.add(queryTypeName);
        return `${ref}: ${queryTypeName}`;
      })
      .join('; ')} }`;
  }

  // Helper to convert route path to a valid TypeScript identifier
  function routeToTypeName(routePath: string, nestedName?: string): string {
    // Convert /hello/[name] to Hello$name, / to Root
    const pathPart =
      routePath === '/'
        ? 'Root'
        : routePath
            .slice(1) // remove leading /
            .split('/')
            .map((segment) => {
              if (segment.startsWith('[') && segment.endsWith(']')) {
                // Dynamic segment: [name] -> $name
                return '$' + segment.slice(1, -1);
              }
              // Static segment: hello -> Hello (capitalize first letter)
              return segment.charAt(0).toUpperCase() + segment.slice(1);
            })
            .join('');

    if (nestedName) {
      // Nested entry point: append _nestedName
      return `Route${pathPart}_${nestedName}`;
    }
    return `Route${pathPart}`;
  }

  // Phase 1: Generate type aliases for nested entry points (leaf nodes - no dependencies)
  const nestedTypeAliases: string[] = [];
  for (const [routePath, page] of fsMetadata.pages.entries()) {
    for (const [epName, nestedPage] of page.nestedEntryPoints.entries()) {
      const typeName = routeToTypeName(routePath, epName);
      const queriesType = buildQueriesType(nestedPage.queries);
      nestedTypeAliases.push(
        `type ${typeName} = { queries: ${queriesType}; entryPoints: {} };`,
      );
    }
  }

  // Phase 2: Generate type aliases for main pages (can reference nested types)
  const mainTypeAliases: string[] = [];
  for (const [routePath, page] of fsMetadata.pages.entries()) {
    const typeName = routeToTypeName(routePath);
    const queriesType = buildQueriesType(page.queries);

    let entryPointsType = '{}';
    if (page.nestedEntryPoints.size > 0) {
      const epTypes = Array.from(page.nestedEntryPoints.keys())
        .map((epName) => {
          const nestedTypeName = routeToTypeName(routePath, epName);
          return `${epName}: EntryPoint<EntryPointComponent<${nestedTypeName}['queries'], ${nestedTypeName}['entryPoints'], {}, {}>, {}>`;
        })
        .join('; ');
      entryPointsType = `{ ${epTypes} }`;
    }

    mainTypeAliases.push(
      `type ${typeName} = { queries: ${queriesType}; entryPoints: ${entryPointsType} };`,
    );
  }

  // Phase 3: Build PageQueryMap entries referencing the type aliases
  const routeTypes: string[] = [];
  for (const [routePath, page] of fsMetadata.pages.entries()) {
    const typeName = routeToTypeName(routePath);
    routeTypes.push(`  '${routePath}': ${typeName}`);

    for (const epName of page.nestedEntryPoints.keys()) {
      const nestedTypeName = routeToTypeName(routePath, epName);
      routeTypes.push(`  '${routePath}#${epName}': ${nestedTypeName}`);
    }
  }

  // Generate import statements for query types
  const queryImportStatements = Array.from(queryImports)
    .map(
      (queryTypeName) =>
        `import type {${queryTypeName}} from '#genfiles/queries/${queryTypeName}.graphql';`,
    )
    .join('\n');

  typesFile.addStatements(`/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 *
 * Type definitions for filesystem-based routing.
 */

import type {EntryPoint, EntryPointComponent, EntryPointProps} from 'react-relay/hooks';
${queryImportStatements ? '\n' + queryImportStatements : ''}

// Route type aliases - nested entry points (leaf nodes)
${nestedTypeAliases.join('\n')}

// Route type aliases - main pages
${mainTypeAliases.join('\n')}

/**
 * Map of route paths to their query types.
 * Nested entry points use the format: '/route#entryPointName'
 */
export interface PageQueryMap {
${routeTypes.join(';\n')}${routeTypes.length > 0 ? ';' : ''}
}

/**
 * Props type for a page component at the given route.
 * Uses EntryPointProps to transform raw query types to PreloadedQuery<...>.
 *
 * @example
 * \`\`\`typescript
 * // Main page
 * export default function BlogPosts({ queries }: PageProps<'/posts'>) {
 *   const data = usePreloadedQuery(query, queries.posts);
 * }
 *
 * // Nested entry point
 * export default function Sidebar({ queries }: PageProps<'/posts#sidebar'>) {
 *   const data = usePreloadedQuery(query, queries.sidebarData);
 * }
 * \`\`\`
 */
export type PageProps<R extends keyof PageQueryMap> = EntryPointProps<
  PageQueryMap[R]['queries'],
  PageQueryMap[R]['entryPoints'],
  {},
  {}
>;
`);

  await typesFile.save();

  logInfo(
    'Generated PageProps types for',
    pc.cyan(`${fsMetadata.pages.size} routes`),
  );
}

// ============================================================================
// Main Generation Functions
// ============================================================================

/**
 * Generates all Pastoria artifacts from the filesystem.
 *
 * This is the main entry point for code generation.
 */
export async function generatePastoriaArtifacts(project: Project) {
  // Scan the pastoria/ directory for routing files
  const fsMetadata = scanFilesystemRoutes(project);

  // Generate all artifacts
  await Promise.all([
    generateRouter(project, fsMetadata),
    generateJsResource(project, fsMetadata),
    generateServerHandler(project, fsMetadata),
    generateTypes(project, fsMetadata),
  ]);

  return fsMetadata;
}

// ============================================================================
// Capabilities Detection
// ============================================================================

export interface PastoriaCapabilities {
  hasAppRoot: boolean;
  hasServerHandler: boolean;
}

/**
 * Detects what capabilities are available based on source files.
 */
export async function detectCapabilities(): Promise<PastoriaCapabilities> {
  const fs = await import('node:fs/promises');

  const hasAppRoot = await fs
    .stat('pastoria/app.tsx')
    .then(() => true)
    .catch(() => false);

  const hasServerHandler = await fs
    .stat('__generated__/router/server_handler.ts')
    .then(() => true)
    .catch(() => false);

  return {hasAppRoot, hasServerHandler};
}

// ============================================================================
// Entry Point Generation (for Vite plugin)
// ============================================================================

/**
 * Generates the client entry point code.
 */
export function generateClientEntry({
  hasAppRoot,
}: PastoriaCapabilities): string {
  const appImport = hasAppRoot ? `import App from './pastoria/app';` : '';
  const appValue = hasAppRoot ? 'App' : 'null';

  return `// Generated by Pastoria.
import {createRouterApp} from '#genfiles/router/router';
${appImport}
import {hydrateRoot} from 'react-dom/client';

async function main() {
  const RouterApp = await createRouterApp();
  hydrateRoot(document, <RouterApp App={${appValue}} />);
}

main();
`;
}

/**
 * Generates the server entry point code.
 */
export function generateServerEntry({
  hasAppRoot,
  hasServerHandler,
}: PastoriaCapabilities): string {
  const appImport = hasAppRoot ? `import App from './pastoria/app';` : '';
  const appValue = hasAppRoot ? 'App' : 'null';

  const serverHandlerImport = hasServerHandler
    ? `import {router as serverHandler} from '#genfiles/router/server_handler';`
    : '';
  const serverHandlerUse = hasServerHandler
    ? '  router.use(serverHandler)'
    : '';

  return `// Generated by Pastoria.
import {JSResource} from '#genfiles/router/js_resource';
import {
  listRoutes,
  router__createAppFromEntryPoint,
  router__loadEntryPoint,
} from '#genfiles/router/router';
import environment from './pastoria/environment';
${appImport}
${serverHandlerImport}
import express from 'express';
import {createRouterHandler} from 'pastoria-runtime/server';
import type {Manifest} from 'vite';

export function createHandler(
  persistedQueries: Record<string, string>,
  manifest?: Manifest,
) {
  const routeHandler = createRouterHandler(
    listRoutes(),
    JSResource.srcOfModuleId,
    router__loadEntryPoint,
    router__createAppFromEntryPoint,
    ${appValue},
    environment,
    persistedQueries,
    manifest,
  );

  const router = express.Router();
  router.use(routeHandler);
  ${serverHandlerUse}

  return router;
}
`;
}
