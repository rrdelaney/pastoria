/**
 * @fileoverview Router Code Generator
 *
 * This script generates type-safe router configuration files using filesystem-based
 * routing, similar to Next.js App Router.
 *
 * ## Filesystem Routing Convention
 *
 * Routes are defined by the directory structure under `pastoria/`:
 * - `pastoria/page.tsx` → Route `/`
 * - `pastoria/about/page.tsx` → Route `/about`
 * - `pastoria/post/[slug]/page.tsx` → Route `/post/:slug`
 * - `pastoria/app.tsx` → Root layout component
 * - `pastoria/api/.../route.ts` → API route handlers
 * - `pastoria/*.page.tsx` → Nested entry points
 * - `pastoria/entrypoint.ts` → Manual entry point definitions
 *
 * ## Page Files
 *
 * Each `page.tsx` should:
 * - Default export a React component
 * - Optionally export `queries` object mapping query refs to Relay query types
 *
 * ## Generated Files
 *
 * Output is placed in `__generated__/router/`:
 * - `js_resource.ts` - Resource configuration for lazy loading
 * - `router.tsx` - Client-side router with type-safe routes
 * - `app_root.ts` - Re-export of the app root component
 * - `environment.ts` - Re-export of the user's PastoriaEnvironment
 * - `server_handler.ts` - API route handlers
 * - `types.ts` - PageProps and other type definitions
 */

import {readFile} from 'node:fs/promises';
import * as path from 'node:path';
import pc from 'picocolors';
import {
  CodeBlockWriter,
  Project,
  SourceFile,
  SyntaxKind,
  ts,
  TypeFlags,
} from 'ts-morph';
import {
  type FilesystemMetadata,
  type FilesystemPage,
  scanFilesystemRoutes,
  toRouterPath,
} from './filesystem.js';
import {logInfo, logWarn} from './logger.js';

// ============================================================================
// Template Loading
// ============================================================================

/**
 * Loads a template file and creates a new source file with a generated header.
 */
async function loadRouterTemplate(project: Project, filename: string) {
  const templatePath = path.join(import.meta.dirname, '../templates', filename);
  const outputPath = path.join('__generated__/router', filename);

  const template = await readFile(templatePath, 'utf-8');
  const warningComment = `/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 */

`;

  return project.createSourceFile(outputPath, warningComment + template, {
    overwrite: true,
  });
}

// ============================================================================
// Query Parameter Collection
// ============================================================================

/**
 * Collects query variables from Relay-generated query type files.
 *
 * For each query, looks up the generated `${queryName}$variables` type
 * and extracts all property names and types.
 */
function collectQueryParameters(
  project: Project,
  queries: string[],
): Map<string, ts.Type> {
  const vars = new Map<string, ts.Type>();

  for (const query of queries) {
    // Find the generated query file
    const queryFile = project.getSourceFile(
      `__generated__/queries/${query}.graphql.ts`,
    );

    if (!queryFile) continue;

    // Get the variables type export
    const variablesType = queryFile
      .getExportedDeclarations()
      .get(`${query}$variables`)
      ?.at(0)
      ?.getType();

    if (!variablesType) continue;

    // Extract each property from the variables type
    for (const property of variablesType.getProperties()) {
      const propertyName = property.getName();
      const propertyType = property.getValueDeclaration()?.getType();

      if (propertyType) {
        vars.set(propertyName, propertyType.compilerType);
      }
    }
  }

  return vars;
}

// ============================================================================
// Zod Schema Generation
// ============================================================================

/**
 * Generates a Zod schema string for a TypeScript type.
 *
 * Used to create runtime validation schemas for route parameters.
 */
function zodSchemaOfType(
  sf: SourceFile,
  tc: ts.TypeChecker,
  t: ts.Type,
): string {
  // Handle type aliases (custom types)
  if (t.aliasSymbol) {
    const decl = t.aliasSymbol.declarations?.at(0);
    if (decl == null) {
      logWarn('Could not handle type:', tc.typeToString(t));
      return `z.any()`;
    } else {
      const importPath = sf.getRelativePathAsModuleSpecifierTo(
        decl.getSourceFile().fileName,
      );
      return `z.transform((s: string) => s as import('${importPath}').${t.aliasSymbol.getName()})`;
    }
  }

  // Handle primitive types
  if (t.getFlags() & TypeFlags.String) {
    return `z.pipe(z.string(), z.transform(decodeURIComponent))`;
  }

  if (t.getFlags() & TypeFlags.Number) {
    return `z.coerce.number<number>()`;
  }

  if (t.getFlags() & TypeFlags.Null) {
    return `z.preprocess(s => s == null ? undefined : s, z.undefined())`;
  }

  // Handle union types
  if (t.isUnion()) {
    const nullishTypes: ts.Type[] = [];
    const nonNullishTypes: ts.Type[] = [];

    for (const s of t.types) {
      const flags = s.getFlags();
      if (flags & TypeFlags.Null || flags & TypeFlags.Undefined) {
        nullishTypes.push(s);
      } else {
        nonNullishTypes.push(s);
      }
    }

    if (nullishTypes.length > 0 && nonNullishTypes.length > 0) {
      const nonOptionalType = t.getNonNullableType();
      return `z.pipe(z.nullish(${zodSchemaOfType(sf, tc, nonOptionalType)}), z.transform(s => s == null ? undefined : s))`;
    } else {
      return `z.union([${t.types.map((it) => zodSchemaOfType(sf, tc, it)).join(', ')}])`;
    }
  }

  // Handle array types
  if (tc.isArrayLikeType(t)) {
    const typeArg = tc.getTypeArguments(t as ts.TypeReference)[0];
    const argZodSchema =
      typeArg == null ? `z.any()` : zodSchemaOfType(sf, tc, typeArg);
    return `z.array(${argZodSchema})`;
  }

  // Fallback
  logWarn('Could not handle type:', tc.typeToString(t));
  return `z.any()`;
}

// ============================================================================
// Entry Point Generation
// ============================================================================

/**
 * Collects all query names from a page and its nested entry points.
 */
function collectAllQueries(page: FilesystemPage): Set<string> {
  const queries = new Set<string>();

  // Add main page queries
  for (const queryName of page.queries.values()) {
    queries.add(queryName);
  }

  // Add nested entry point queries
  for (const nestedPage of page.nestedEntryPoints.values()) {
    for (const queryName of nestedPage.queries.values()) {
      queries.add(queryName);
    }
  }

  return queries;
}

/**
 * Writes an entry point definition for a filesystem-based page.
 *
 * Generates a getPreloadProps function that:
 * 1. Sets up query preloading with the provided variables
 * 2. Includes any nested entry points
 *
 * Note: Params are already parsed and typed by ROUTER_CONF schema via
 * EntryPointParams<R>, so no additional parsing is needed here.
 */
function writeFilesystemEntryPoint(
  writer: CodeBlockWriter,
  project: Project,
  page: FilesystemPage,
  resourceName: string,
  routePath: string,
  schemaExpression: string,
) {
  const hasNestedEntryPoints = page.nestedEntryPoints.size > 0;

  // Define schema locally so it can be referenced by wrappedGetPreloadProps
  writer.writeLine(`const schema = ${schemaExpression};`);

  // Generate query helper functions
  writer.write('const queryHelpers = ').block(() => {
    for (const [queryRef, queryName] of page.queries.entries()) {
      writer.writeLine(
        `${queryRef}: (variables: ${queryName}$variables) => ({ parameters: ${queryName}Parameters, variables }),`,
      );
    }
  });
  writer.writeLine(';');

  // Generate entry point helper functions
  writer.write('const entryPointHelpers = ').block(() => {
    for (const [epName, nestedPage] of page.nestedEntryPoints.entries()) {
      const nestedResourceName = `${resourceName}#${epName}`;

      // Build the combined variables type from all queries in this nested entry point
      const nestedQueryNames = Array.from(nestedPage.queries.values());
      const variablesType =
        nestedQueryNames.length === 0
          ? 'Record<string, never>'
          : nestedQueryNames.map((q) => `${q}$variables`).join(' & ');

      writer
        .write(`${epName}: (variables: ${variablesType}) => (`)
        .block(() => {
          writer.writeLine('entryPointParams: {},');
          writer.write('entryPoint: ').block(() => {
            writer.writeLine(
              `root: JSResource.fromModuleId('${nestedResourceName}'),`,
            );
            writer.write('getPreloadProps() ').block(() => {
              writer.write('return ').block(() => {
                writer.write('queries: ').block(() => {
                  for (const [
                    nestedQueryRef,
                    nestedQueryName,
                  ] of nestedPage.queries.entries()) {
                    writer.writeLine(
                      `${nestedQueryRef}: { parameters: ${nestedQueryName}Parameters, variables },`,
                    );
                  }
                });
                writer.writeLine(',');
                writer.writeLine('entryPoints: undefined');
              });
            });
          });
        });
      writer.writeLine('),');
    }
  });
  writer.writeLine(';');

  // Write getPreloadProps using the helpers
  writer
    .write(
      `function getPreloadProps({params, queries, entryPoints}: EntryPointParams<'${routePath}'>)`,
    )
    .block(() => {
      // Params are already parsed and typed via EntryPointParams<R>
      writer.writeLine('const variables = params;');

      writer.write('return ').block(() => {
        // Write queries using helpers
        writer.write('queries: ').block(() => {
          for (const [queryRef, _queryName] of page.queries.entries()) {
            const queryVars = collectQueryParameters(project, [
              page.queries.get(queryRef)!,
            ]);
            if (queryVars.size > 0) {
              const varNames = Array.from(queryVars.keys());
              writer.writeLine(
                `${queryRef}: queries.${queryRef}({${varNames.map((v) => `${v}: variables.${v}`).join(', ')}}),`,
              );
            } else {
              writer.writeLine(`${queryRef}: queries.${queryRef}({}),`);
            }
          }
        });
        writer.writeLine(',');

        // Write entry points using helpers
        if (hasNestedEntryPoints) {
          writer.write('entryPoints: ').block(() => {
            for (const [
              epName,
              nestedPage,
            ] of page.nestedEntryPoints.entries()) {
              // Collect all variables needed by this nested entry point
              const nestedVars = collectQueryParameters(
                project,
                Array.from(nestedPage.queries.values()),
              );
              if (nestedVars.size > 0) {
                const varNames = Array.from(nestedVars.keys());
                writer.writeLine(
                  `${epName}: entryPoints.${epName}({${varNames.map((v) => `${v}: variables.${v}`).join(', ')}}),`,
                );
              } else {
                writer.writeLine(`${epName}: entryPoints.${epName}({}),`);
              }
            }
          });
        } else {
          writer.writeLine('entryPoints: undefined');
        }
      });
    });
}

// ============================================================================
// Router Generation
// ============================================================================

/**
 * Generates the router.tsx file with all route configurations.
 *
 * For each page discovered in the filesystem:
 * 1. Generates an entry point function with getPreloadProps
 * 2. Creates a route configuration entry with Zod schema
 */
async function generateRouter(
  project: Project,
  fsMetadata: FilesystemMetadata,
) {
  const routerTemplate = await loadRouterTemplate(project, 'router.tsx');

  // Get the ROUTER_CONF object to add routes to
  const routerConf = routerTemplate
    .getVariableDeclarationOrThrow('ROUTER_CONF')
    .getInitializerIfKindOrThrow(SyntaxKind.AsExpression)
    .getExpressionIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

  // Only remove the noop placeholder if there are actual routes
  // (keeping it prevents type errors when the config is empty)
  const hasRoutes =
    fsMetadata.pages.size > 0 || fsMetadata.entryPoints.size > 0;
  if (hasRoutes) {
    routerConf.getPropertyOrThrow('noop').remove();
  }

  // Add JSResource import
  routerTemplate.addImportDeclaration({
    moduleSpecifier: './js_resource',
    namedImports: ['JSResource', 'ModuleType'],
  });

  // Add helper types import from types.ts
  routerTemplate.addImportDeclaration({
    moduleSpecifier: './types',
    namedImports: ['QueryHelpersForRoute', 'EntryPointHelpersForRoute'],
    isTypeOnly: true,
  });

  const tc = project.getTypeChecker().compilerObject;

  // Process each page
  for (const [routePath, page] of fsMetadata.pages.entries()) {
    // Create a unique resource name for this page
    const resourceName = `fs:page(${routePath})`;
    const safeResourceName = resourceName.replace(/[^a-zA-Z0-9]/g, '_');

    // Check if this page has a custom entrypoint.ts
    const hasCustomEntryPoint = page.customEntryPointPath != null;

    // Import custom entrypoint exports if present
    let customEntryPointAlias: string | null = null;
    if (hasCustomEntryPoint) {
      customEntryPointAlias = `customEp_${safeResourceName}`;
      routerTemplate.addImportDeclaration({
        moduleSpecifier: routerTemplate.getRelativePathAsModuleSpecifierTo(
          path.join(process.cwd(), page.customEntryPointPath!),
        ),
        defaultImport: customEntryPointAlias,
        namedImports: [
          {name: 'schema', alias: `${customEntryPointAlias}_schema`},
        ],
      });
    }

    // Collect all queries consumed by this page and its nested entry points
    const consumedQueries = collectAllQueries(page);

    // Add imports for query parameters and variable types (only needed for generated entry points)
    if (!hasCustomEntryPoint) {
      for (const queryName of consumedQueries) {
        routerTemplate.addImportDeclaration({
          moduleSpecifier: `#genfiles/queries/${queryName}$parameters`,
          defaultImport: `${queryName}Parameters`,
        });
        // Add type-only import for variables (doesn't import runtime code)
        routerTemplate.addImportDeclaration({
          moduleSpecifier: `#genfiles/queries/${queryName}.graphql`,
          namedImports: [`${queryName}$variables`],
          isTypeOnly: true,
        });
      }
    }

    // Build params schema from route params + query variables
    const params = new Map<string, ts.Type>();

    // Add filesystem params as string types
    for (const paramName of page.params) {
      params.set(paramName, tc.getStringType());
    }

    // Also include query variables (only needed for generated entry points)
    if (!hasCustomEntryPoint && consumedQueries.size > 0) {
      const queryParams = collectQueryParameters(
        project,
        Array.from(consumedQueries),
      );
      // Merge query params with route params (route params take precedence)
      for (const [paramName, paramType] of queryParams) {
        if (!params.has(paramName)) {
          params.set(paramName, paramType);
        }
      }
    }

    // Build schema expression string for the entry point to capture
    let schemaExpression: string;
    if (hasCustomEntryPoint) {
      // Use the imported schema from the custom entrypoint
      schemaExpression = `${customEntryPointAlias}_schema`;
    } else if (params.size === 0) {
      schemaExpression = 'z.object({})';
    } else {
      const schemaFields = Array.from(params.entries())
        .map(
          ([paramName, paramType]) =>
            `${paramName}: ${zodSchemaOfType(routerTemplate, tc, paramType)}`,
        )
        .join(', ');
      schemaExpression = `z.object({ ${schemaFields} })`;
    }

    // Generate the entry point function
    if (hasCustomEntryPoint) {
      // Custom entrypoint: use imported getPreloadProps but still wrap with helpers
      // First, add query parameter imports needed for the helpers
      for (const queryName of consumedQueries) {
        routerTemplate.addImportDeclaration({
          moduleSpecifier: `#genfiles/queries/${queryName}$parameters`,
          defaultImport: `${queryName}Parameters`,
        });
        routerTemplate.addImportDeclaration({
          moduleSpecifier: `#genfiles/queries/${queryName}.graphql`,
          namedImports: [`${queryName}$variables`],
          isTypeOnly: true,
        });
      }

      routerTemplate.addFunction({
        name: `entrypoint_${safeResourceName}`,
        statements: (writer) => {
          // Generate query helpers
          writer.write('const queryHelpers = ').block(() => {
            for (const [queryRef, queryName] of page.queries.entries()) {
              writer.writeLine(
                `${queryRef}: (variables: ${queryName}$variables) => ({ parameters: ${queryName}Parameters, variables }),`,
              );
            }
          });
          writer.writeLine(';');

          // Generate entry point helpers
          writer.write('const entryPointHelpers = ').block(() => {
            for (const [
              epName,
              nestedPage,
            ] of page.nestedEntryPoints.entries()) {
              const nestedResourceName = `${resourceName}#${epName}`;
              const nestedQueryNames = Array.from(nestedPage.queries.values());
              const variablesType =
                nestedQueryNames.length === 0
                  ? 'Record<string, never>'
                  : nestedQueryNames.map((q) => `${q}$variables`).join(' & ');

              writer
                .write(`${epName}: (variables: ${variablesType}) => (`)
                .block(() => {
                  writer.writeLine('entryPointParams: {},');
                  writer.write('entryPoint: ').block(() => {
                    writer.writeLine(
                      `root: JSResource.fromModuleId('${nestedResourceName}'),`,
                    );
                    writer.write('getPreloadProps() ').block(() => {
                      writer.write('return ').block(() => {
                        writer.write('queries: ').block(() => {
                          for (const [
                            nestedQueryRef,
                            nestedQueryName,
                          ] of nestedPage.queries.entries()) {
                            writer.writeLine(
                              `${nestedQueryRef}: { parameters: ${nestedQueryName}Parameters, variables },`,
                            );
                          }
                        });
                        writer.writeLine(',');
                        writer.writeLine('entryPoints: undefined');
                      });
                    });
                  });
                });
              writer.writeLine('),');
            }
          });
          writer.writeLine(';');

          writer.write('return ').block(() => {
            writer.writeLine(
              `root: JSResource.fromModuleId('${resourceName}'),`,
            );
            writer.writeLine(
              `getPreloadProps: (p: {params: z.infer<typeof ${customEntryPointAlias}_schema>}) => ${customEntryPointAlias}({`,
            );
            writer.writeLine('  params: p.params,');
            writer.writeLine('  queries: queryHelpers,');
            writer.writeLine('  entryPoints: entryPointHelpers,');
            writer.writeLine('}),');
          });
        },
      });
    } else {
      // Generated entrypoint: create getPreloadProps from page queries
      routerTemplate.addFunction({
        name: `entrypoint_${safeResourceName}`,
        statements: (writer) => {
          writeFilesystemEntryPoint(
            writer,
            project,
            page,
            resourceName,
            routePath,
            schemaExpression,
          );
          writer.write('return ').block(() => {
            writer.writeLine(
              `root: JSResource.fromModuleId('${resourceName}'),`,
            );
            writer.writeLine(
              'getPreloadProps: (p: {params: Record<string, unknown>}) => getPreloadProps({',
            );
            writer.writeLine('  params: p.params as z.infer<typeof schema>,');
            writer.writeLine('  queries: queryHelpers,');
            writer.writeLine('  entryPoints: entryPointHelpers,');
            writer.writeLine('}),');
          });
        },
      });
    }

    // Add route configuration (uses bracket format, converted to colon for radix3 at runtime)
    routerConf.addPropertyAssignment({
      name: `"${routePath}"`,
      initializer: (writer) => {
        writer.write('{').indent(() => {
          writer.writeLine(`entrypoint: entrypoint_${safeResourceName}(),`);
          writer.writeLine(`schema: ${schemaExpression}`);
        });
        writer.write('} as const');
      },
    });

    logInfo(
      'Created route',
      pc.cyan(routePath),
      'from',
      pc.yellow(page.filePath),
      hasCustomEntryPoint ? '(custom entrypoint)' : '',
    );
  }

  await routerTemplate.save();
}

// ============================================================================
// JS Resource Generation
// ============================================================================

/**
 * Generates the js_resource.ts file for lazy loading.
 *
 * Each page.tsx and *.page.tsx file becomes a lazy-loadable resource.
 */
async function generateJsResource(
  project: Project,
  fsMetadata: FilesystemMetadata,
) {
  const jsResourceTemplate = await loadRouterTemplate(
    project,
    'js_resource.ts',
  );

  const resourceConf = jsResourceTemplate
    .getVariableDeclarationOrThrow('RESOURCE_CONF')
    .getInitializerIfKindOrThrow(SyntaxKind.AsExpression)
    .getExpressionIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

  // Only remove the noop placeholder if there are actual pages
  const hasPages = fsMetadata.pages.size > 0;
  if (hasPages) {
    resourceConf.getPropertyOrThrow('noop').remove();
  }

  // Process main pages
  for (const [routePath, page] of fsMetadata.pages.entries()) {
    const resourceName = `fs:page(${routePath})`;
    const moduleSpecifier =
      jsResourceTemplate.getRelativePathAsModuleSpecifierTo(
        path.join(process.cwd(), page.filePath),
      );

    resourceConf.addPropertyAssignment({
      name: `"${resourceName}"`,
      initializer: (writer) => {
        writer.block(() => {
          writer.writeLine(`src: "${page.filePath}",`);
          writer.writeLine(
            `loader: (): Promise<ComponentType<PageProps<'${routePath}'>>> => import("${moduleSpecifier}").then(m => m.default)`,
          );
        });
      },
    });

    logInfo(
      'Created resource',
      pc.cyan(resourceName),
      'from',
      pc.yellow(page.filePath),
    );

    // Process nested entry points for this page
    for (const [epName, nestedPage] of page.nestedEntryPoints.entries()) {
      const nestedResourceName = `${resourceName}#${epName}`;
      const nestedModuleSpecifier =
        jsResourceTemplate.getRelativePathAsModuleSpecifierTo(
          path.join(process.cwd(), nestedPage.filePath),
        );

      // Nested entry points use flattened keys like '/#search_results'
      const nestedRouteKey = `${routePath}#${epName}`;
      resourceConf.addPropertyAssignment({
        name: `"${nestedResourceName}"`,
        initializer: (writer) => {
          writer.block(() => {
            writer.writeLine(`src: "${nestedPage.filePath}",`);
            writer.writeLine(
              `loader: (): Promise<ComponentType<PageProps<'${nestedRouteKey}'>>> => import("${nestedModuleSpecifier}").then(m => m.default)`,
            );
          });
        },
      });

      logInfo(
        'Created nested resource',
        pc.cyan(nestedResourceName),
        'from',
        pc.yellow(nestedPage.filePath),
      );
    }
  }

  await jsResourceTemplate.save();
}

// ============================================================================
// Server Handler Generation
// ============================================================================

/**
 * Generates server_handler.ts with API route handlers.
 *
 * Each route.ts file in the filesystem exports an express.Router
 * that handles requests at that path.
 */
async function generateServerHandler(
  project: Project,
  fsMetadata: FilesystemMetadata,
) {
  if (fsMetadata.apiRoutes.size === 0) {
    // No API routes found, delete the file if it exists
    await project
      .getSourceFile('__generated__/router/server_handler.ts')
      ?.deleteImmediately();
    return;
  }

  const serverHandlerFile = project.createSourceFile(
    '__generated__/router/server_handler.ts',
    `/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 */

import express from 'express';
export const router = express.Router();
`,
    {overwrite: true},
  );

  let importIndex = 0;
  for (const [routePath, apiRoute] of fsMetadata.apiRoutes.entries()) {
    // Convert [param] to :param for Express router
    const routerPath = toRouterPath(routePath);
    const importAlias = `route${importIndex++}`;
    const moduleSpecifier =
      serverHandlerFile.getRelativePathAsModuleSpecifierTo(
        path.join(process.cwd(), apiRoute.filePath),
      );

    serverHandlerFile.addImportDeclaration({
      moduleSpecifier,
      defaultImport: importAlias,
    });

    serverHandlerFile.addStatements(
      `router.use('${routerPath}', ${importAlias});`,
    );

    logInfo(
      'Created API route',
      pc.cyan(routePath),
      'from',
      pc.yellow(apiRoute.filePath),
    );
  }

  await serverHandlerFile.save();
}

// ============================================================================
// Type Generation
// ============================================================================

/**
 * Generates types.ts with PageProps type definitions.
 *
 * Creates types like PageProps<'/posts'> that include:
 * - queries: Preloaded query references
 * - entryPoints: Nested entry point references
 */
async function generateTypes(project: Project, fsMetadata: FilesystemMetadata) {
  const typesFile = project.createSourceFile(
    '__generated__/router/types.ts',
    '',
    {overwrite: true},
  );

  // Collect all query types to import (both the query type and $variables type)
  const queryImports = new Set<string>();
  const variablesImports = new Set<string>();

  // Helper to build queries type string
  function buildQueriesType(queries: Map<string, string>): string {
    if (queries.size === 0) return '{}';
    return `{ ${Array.from(queries.entries())
      .map(([ref, queryTypeName]) => {
        queryImports.add(queryTypeName);
        return `${ref}: ${queryTypeName}`;
      })
      .join('; ')} }`;
  }

  // Helper to build query helper type for a route
  function buildQueryHelpersType(queries: Map<string, string>): string {
    if (queries.size === 0) return '{}';
    return `{ ${Array.from(queries.entries())
      .map(([ref, queryTypeName]) => {
        variablesImports.add(queryTypeName);
        return `${ref}: (variables: ${queryTypeName}$variables) => { parameters: unknown; variables: ${queryTypeName}$variables }`;
      })
      .join('; ')} }`;
  }

  // Helper to build entry point helper type for a route
  function buildEntryPointHelpersType(
    routePath: string,
    nestedEntryPoints: Map<string, FilesystemPage>,
  ): string {
    if (nestedEntryPoints.size === 0) return '{}';
    return `{ ${Array.from(nestedEntryPoints.entries())
      .map(([epName, nestedPage]) => {
        const nestedTypeName = routeToTypeName(routePath, epName);
        // Build intersection of all query variable types for this nested entry point
        const queryNames = Array.from(nestedPage.queries.values());
        queryNames.forEach((q) => variablesImports.add(q));
        const variablesType =
          queryNames.length === 0
            ? 'Record<string, never>'
            : queryNames.map((q) => `${q}$variables`).join(' & ');
        // Optional entry points can return undefined
        const baseReturnType = `{ entryPointParams: Record<string, never>; entryPoint: EntryPoint<EntryPointComponent<${nestedTypeName}['queries'], ${nestedTypeName}['entryPoints'], {}, {}>, {}> }`;
        const returnType = nestedPage.optional
          ? `${baseReturnType} | undefined`
          : baseReturnType;
        return `${epName}: (variables: ${variablesType}) => ${returnType}`;
      })
      .join('; ')} }`;
  }

  // Helper to convert route path to a valid TypeScript identifier
  function routeToTypeName(routePath: string, nestedName?: string): string {
    // Convert /hello/[name] to Hello$name, / to Root
    const pathPart =
      routePath === '/'
        ? 'Root'
        : routePath
            .slice(1) // remove leading /
            .split('/')
            .map((segment) => {
              if (segment.startsWith('[') && segment.endsWith(']')) {
                // Dynamic segment: [name] -> $name
                return '$' + segment.slice(1, -1);
              }
              // Static segment: hello -> Hello (capitalize first letter)
              return segment.charAt(0).toUpperCase() + segment.slice(1);
            })
            .join('');

    if (nestedName) {
      // Nested entry point: append _nestedName
      return `Route${pathPart}_${nestedName}`;
    }
    return `Route${pathPart}`;
  }

  // Phase 1: Generate type aliases for nested entry points (leaf nodes - no dependencies)
  const nestedTypeAliases: string[] = [];
  for (const [routePath, page] of fsMetadata.pages.entries()) {
    for (const [epName, nestedPage] of page.nestedEntryPoints.entries()) {
      const typeName = routeToTypeName(routePath, epName);
      const queriesType = buildQueriesType(nestedPage.queries);
      nestedTypeAliases.push(
        `type ${typeName} = { queries: ${queriesType}; entryPoints: {} };`,
      );
    }
  }

  // Phase 2: Generate type aliases for main pages (can reference nested types)
  const mainTypeAliases: string[] = [];
  for (const [routePath, page] of fsMetadata.pages.entries()) {
    const typeName = routeToTypeName(routePath);
    const queriesType = buildQueriesType(page.queries);

    let entryPointsType = '{}';
    if (page.nestedEntryPoints.size > 0) {
      const epTypes = Array.from(page.nestedEntryPoints.entries())
        .map(([epName, nestedPage]) => {
          const nestedTypeName = routeToTypeName(routePath, epName);
          const optionalMarker = nestedPage.optional ? '?' : '';
          return `${epName}${optionalMarker}: EntryPoint<EntryPointComponent<${nestedTypeName}['queries'], ${nestedTypeName}['entryPoints'], {}, {}>, {}>`;
        })
        .join('; ');
      entryPointsType = `{ ${epTypes} }`;
    }

    mainTypeAliases.push(
      `type ${typeName} = { queries: ${queriesType}; entryPoints: ${entryPointsType} };`,
    );
  }

  // Phase 3: Build PageQueryMap entries referencing the type aliases
  const routeTypes: string[] = [];
  for (const [routePath, page] of fsMetadata.pages.entries()) {
    const typeName = routeToTypeName(routePath);
    routeTypes.push(`  '${routePath}': ${typeName}`);

    for (const epName of page.nestedEntryPoints.keys()) {
      const nestedTypeName = routeToTypeName(routePath, epName);
      routeTypes.push(`  '${routePath}#${epName}': ${nestedTypeName}`);
    }
  }

  // Phase 4: Generate helper type aliases for each route
  const queryHelperAliases: string[] = [];
  const entryPointHelperAliases: string[] = [];
  const queryHelpersMapEntries: string[] = [];
  const entryPointHelpersMapEntries: string[] = [];

  for (const [routePath, page] of fsMetadata.pages.entries()) {
    const typeName = routeToTypeName(routePath);

    // Query helpers type
    const queryHelpersType = buildQueryHelpersType(page.queries);
    queryHelperAliases.push(
      `type QueryHelpers_${typeName} = ${queryHelpersType};`,
    );
    queryHelpersMapEntries.push(`  '${routePath}': QueryHelpers_${typeName}`);

    // Entry point helpers type
    const entryPointHelpersType = buildEntryPointHelpersType(
      routePath,
      page.nestedEntryPoints,
    );
    entryPointHelperAliases.push(
      `type EntryPointHelpers_${typeName} = ${entryPointHelpersType};`,
    );
    entryPointHelpersMapEntries.push(
      `  '${routePath}': EntryPointHelpers_${typeName}`,
    );
  }

  // Generate import statements for query types
  const queryImportStatements = Array.from(queryImports)
    .map(
      (queryTypeName) =>
        `import type {${queryTypeName}} from '#genfiles/queries/${queryTypeName}.graphql';`,
    )
    .join('\n');

  // Generate import statements for $variables types
  const variablesImportStatements = Array.from(variablesImports)
    .map(
      (queryTypeName) =>
        `import type {${queryTypeName}$variables} from '#genfiles/queries/${queryTypeName}.graphql';`,
    )
    .join('\n');

  typesFile.addStatements(`/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 *
 * Type definitions for filesystem-based routing.
 */

import type {EntryPoint, EntryPointComponent, EntryPointProps} from 'react-relay/hooks';
${queryImportStatements ? '\n' + queryImportStatements : ''}
${variablesImportStatements ? '\n' + variablesImportStatements : ''}

// Route type aliases - nested entry points (leaf nodes)
${nestedTypeAliases.join('\n')}

// Route type aliases - main pages
${mainTypeAliases.join('\n')}

/**
 * Map of route paths to their query types.
 * Nested entry points use the format: '/route#entryPointName'
 */
export interface PageQueryMap {
${routeTypes.join(';\n')}${routeTypes.length > 0 ? ';' : ''}
}

// Query helper type aliases for each route
${queryHelperAliases.join('\n')}

// Entry point helper type aliases for each route
${entryPointHelperAliases.join('\n')}

/**
 * Query helper functions for a route.
 * Each helper takes typed variables and returns {parameters, variables} for Relay.
 */
export interface QueryHelpersMap {
${queryHelpersMapEntries.join(';\n')}${queryHelpersMapEntries.length > 0 ? ';' : ''}
}

export type QueryHelpersForRoute<R extends string> = R extends keyof QueryHelpersMap
  ? QueryHelpersMap[R]
  : {};

/**
 * Entry point helper functions for a route.
 * Each helper takes typed variables and returns the nested entry point configuration.
 */
export interface EntryPointHelpersMap {
${entryPointHelpersMapEntries.join(';\n')}${entryPointHelpersMapEntries.length > 0 ? ';' : ''}
}

export type EntryPointHelpersForRoute<R extends string> = R extends keyof EntryPointHelpersMap
  ? EntryPointHelpersMap[R]
  : {};

/**
 * Props type for a page component at the given route.
 * Uses EntryPointProps to transform raw query types to PreloadedQuery<...>.
 *
 * @example
 * \`\`\`typescript
 * // Main page
 * export default function BlogPosts({ queries }: PageProps<'/posts'>) {
 *   const data = usePreloadedQuery(query, queries.posts);
 * }
 *
 * // Nested entry point
 * export default function Sidebar({ queries }: PageProps<'/posts#sidebar'>) {
 *   const data = usePreloadedQuery(query, queries.sidebarData);
 * }
 * \`\`\`
 */
export type PageProps<R extends keyof PageQueryMap> = EntryPointProps<
  PageQueryMap[R]['queries'],
  PageQueryMap[R]['entryPoints'],
  {},
  {}
>;

/**
 * Return type for getPreloadProps in entrypoint.ts files.
 * This type matches the structure expected by Relay's loadEntryPoint.
 *
 * @example
 * \`\`\`typescript
 * export default function getPreloadProps({
 *   params,
 *   queries,
 *   entryPoints,
 * }: EntryPointParams<'/posts'>): PreloadPropsForRoute<'/posts'> {
 *   return {
 *     queries: {
 *       postsQuery: queries.postsQuery(params),
 *     },
 *     entryPoints: {
 *       sidebar: entryPoints.sidebar({}),
 *     },
 *   };
 * }
 * \`\`\`
 */
export type PreloadPropsForRoute<R extends keyof PageQueryMap> = {
  queries: {
    [K in keyof PageQueryMap[R]['queries']]: {
      parameters: unknown;
      variables: unknown;
    };
  };
  entryPoints: PageQueryMap[R]['entryPoints'] extends Record<string, never>
    ? undefined
    : {
        [K in keyof PageQueryMap[R]['entryPoints']]: {
          entryPointParams: unknown;
          entryPoint: unknown;
        };
      };
};
`);

  await typesFile.save();

  logInfo(
    'Generated PageProps types for',
    pc.cyan(`${fsMetadata.pages.size} routes`),
  );
}

// ============================================================================
// Main Generation Functions
// ============================================================================

/**
 * Generates all Pastoria artifacts from the filesystem.
 *
 * This is the main entry point for code generation.
 */
export async function generatePastoriaArtifacts(project: Project) {
  // Scan the pastoria/ directory for routing files
  const fsMetadata = scanFilesystemRoutes(project);

  // Generate all artifacts
  await Promise.all([
    generateRouter(project, fsMetadata),
    generateJsResource(project, fsMetadata),
    generateServerHandler(project, fsMetadata),
    generateTypes(project, fsMetadata),
  ]);

  return fsMetadata;
}

// ============================================================================
// Capabilities Detection
// ============================================================================

export interface PastoriaCapabilities {
  hasAppRoot: boolean;
  hasServerHandler: boolean;
}

/**
 * Detects what capabilities are available based on source files.
 */
export async function detectCapabilities(): Promise<PastoriaCapabilities> {
  const fs = await import('node:fs/promises');

  const hasAppRoot = await fs
    .stat('pastoria/app.tsx')
    .then(() => true)
    .catch(() => false);

  const hasServerHandler = await fs
    .stat('__generated__/router/server_handler.ts')
    .then(() => true)
    .catch(() => false);

  return {hasAppRoot, hasServerHandler};
}

// ============================================================================
// Entry Point Generation (for Vite plugin)
// ============================================================================

/**
 * Generates the client entry point code.
 */
export function generateClientEntry({
  hasAppRoot,
}: PastoriaCapabilities): string {
  const appImport = hasAppRoot ? `import App from './pastoria/app';` : '';
  const appValue = hasAppRoot ? 'App' : 'null';

  return `// Generated by Pastoria.
import {createRouterApp} from '#genfiles/router/router';
${appImport}
import {hydrateRoot} from 'react-dom/client';

async function main() {
  const RouterApp = await createRouterApp();
  hydrateRoot(document, <RouterApp App={${appValue}} />);
}

main();
`;
}

/**
 * Generates the server entry point code.
 */
export function generateServerEntry({
  hasAppRoot,
  hasServerHandler,
}: PastoriaCapabilities): string {
  const appImport = hasAppRoot ? `import App from './pastoria/app';` : '';
  const appValue = hasAppRoot ? 'App' : 'null';

  const serverHandlerImport = hasServerHandler
    ? `import {router as serverHandler} from '#genfiles/router/server_handler';`
    : '';
  const serverHandlerUse = hasServerHandler
    ? '  router.use(serverHandler)'
    : '';

  return `// Generated by Pastoria.
import {JSResource} from '#genfiles/router/js_resource';
import {
  listRoutes,
  router__createAppFromEntryPoint,
  router__loadEntryPoint,
} from '#genfiles/router/router';
import environment from './pastoria/environment';
${appImport}
${serverHandlerImport}
import express from 'express';
import {createRouterHandler} from 'pastoria-runtime/server';
import type {Manifest} from 'vite';

export function createHandler(
  persistedQueries: Record<string, string>,
  manifest?: Manifest,
) {
  const routeHandler = createRouterHandler(
    listRoutes(),
    JSResource.srcOfModuleId,
    router__loadEntryPoint,
    router__createAppFromEntryPoint,
    ${appValue},
    environment,
    persistedQueries,
    manifest,
  );

  const router = express.Router();
  router.use(routeHandler);
  ${serverHandlerUse}

  return router;
}
`;
}
