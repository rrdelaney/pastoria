/**
 * @fileoverview Router Code Generator
 *
 * This script generates type-safe router configuration files by scanning TypeScript
 * source code for JSDoc annotations. It's part of the "Pastoria" routing framework.
 *
 * How it works:
 * 1. Scans all TypeScript files in the project for exported functions/classes
 * 2. Looks for JSDoc tags: @route, @resource, @appRoot, and @param
 * 3. Looks for exported classes that extend PastoriaRootContext for GraphQL context
 * 4. Generates files from templates:
 *    - js_resource.ts: Resource configuration for lazy loading
 *    - router.tsx: Client-side router with type-safe routes
 *    - app_root.ts: Re-export of the app root component (if @appRoot is found)
 *    - context.ts: Re-export of user's context class, or generate a default one
 *
 * Usage:
 * - Add @route <route-name> to functions to create routes
 * - Add @param <name> <type> to document route parameters
 * - Add @resource <resource-name> to exports for lazy loading
 * - Add @appRoot to a component to designate it as the application root wrapper
 * - Add @gqlContext to a class extending PastoriaRootContext to provide a custom GraphQL context
 *
 * The generator automatically creates Zod schemas for route parameters based on
 * TypeScript types, enabling runtime validation and type safety.
 */

import {readFile} from 'node:fs/promises';
import * as path from 'node:path';
import {getLogger} from 'pastoria-logger';
import pc from 'picocolors';
import {Project, SourceFile, Symbol, SyntaxKind, ts, TypeFlags} from 'ts-morph';

const logger = getLogger('pastoria:generate');

async function loadRouterTemplates(project: Project, filename: string) {
  async function loadSourceFile(fileName: string, templateFileName: string) {
    const template = await readFile(templateFileName, 'utf-8');
    const warningComment = `/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly. Instead, edit the template at ${path.basename(templateFileName)}.
 */

`;
    return project.createSourceFile(fileName, warningComment + template, {
      overwrite: true,
    });
  }

  const template = path.join(import.meta.dirname, '../templates', filename);
  const output = path.join('__generated__/router', filename);
  return loadSourceFile(output, template);
}

type RouterResource = {
  resourceName: string;
  sourceFile: SourceFile;
  symbol: Symbol;
};

type RouterRoute = {
  routeName: string;
  sourceFile: SourceFile;
  symbol: Symbol;
  params: Map<string, ts.Type>;
};

type AppRoot = {
  sourceFile: SourceFile;
  symbol: Symbol;
};

type GqlContext = {
  sourceFile: SourceFile;
  symbol: Symbol;
};

interface PastoriaMetadata {
  resources: RouterResource[];
  routes: RouterRoute[];
  appRoot: AppRoot | null;
  gqlContext: GqlContext | null;
}

// Regex to quickly check if a file contains any Pastoria JSDoc tags
const PASTORIA_TAG_REGEX = /@(route|resource|appRoot|param|gqlContext)\b/;

function collectPastoriaMetadata(project: Project): PastoriaMetadata {
  const resources: RouterResource[] = [];
  const routes: RouterRoute[] = [];
  let appRoot: AppRoot | null = null;
  let gqlContext: GqlContext | null = null;

  function visitRouterNodes(sourceFile: SourceFile) {
    // Skip generated files
    if (sourceFile.getFilePath().includes('__generated__')) {
      return;
    }

    // Skip files that don't contain any Pastoria JSDoc tags
    const fileText = sourceFile.getFullText();
    if (!PASTORIA_TAG_REGEX.test(fileText)) {
      return;
    }

    sourceFile.getExportSymbols().forEach((symbol) => {
      let routerResource = null as RouterResource | null;
      let routerRoute = null as RouterRoute | null;
      const routeParams = new Map<string, ts.Type>();

      function visitJSDocTags(tag: ts.JSDoc | ts.JSDocTag) {
        if (ts.isJSDoc(tag)) {
          tag.tags?.forEach(visitJSDocTags);
        } else if (ts.isJSDocParameterTag(tag)) {
          const typeNode = tag.typeExpression?.type;
          const tc = project.getTypeChecker().compilerObject;

          const type =
            typeNode == null
              ? tc.getUnknownType()
              : tc.getTypeFromTypeNode(typeNode);

          routeParams.set(tag.name.getText(), type);
        } else if (typeof tag.comment === 'string') {
          switch (tag.tagName.getText()) {
            case 'route': {
              routerRoute = {
                routeName: tag.comment,
                sourceFile,
                symbol,
                params: routeParams,
              };
              break;
            }
            case 'resource': {
              routerResource = {
                resourceName: tag.comment,
                sourceFile,
                symbol,
              };
              break;
            }
          }
        } else {
          // Handle tags without comments (like @appRoot, @gqlContext)
          switch (tag.tagName.getText()) {
            case 'appRoot': {
              if (appRoot != null) {
                logger.warn(
                  'Multiple @appRoot tags found. Using the first one.',
                );
              } else {
                appRoot = {
                  sourceFile,
                  symbol,
                };
              }
              break;
            }
            case 'gqlContext': {
              // Check if this class extends PastoriaRootContext
              const declarations = symbol.getDeclarations();
              let extendsPastoriaRootContext = false;

              for (const decl of declarations) {
                if (decl.isKind(SyntaxKind.ClassDeclaration)) {
                  const classDecl = decl.asKindOrThrow(
                    SyntaxKind.ClassDeclaration,
                  );
                  const extendsClause = classDecl.getExtends();
                  if (extendsClause != null) {
                    const baseClassName = extendsClause
                      .getExpression()
                      .getText();
                    if (baseClassName === 'PastoriaRootContext') {
                      extendsPastoriaRootContext = true;
                      break;
                    }
                  }
                }
              }

              if (extendsPastoriaRootContext) {
                if (gqlContext != null) {
                  logger.warn(
                    'Multiple classes with @gqlContext extending PastoriaRootContext found. Using the first one.',
                  );
                } else {
                  gqlContext = {
                    sourceFile,
                    symbol,
                  };
                }
              }
              break;
            }
          }
        }
      }

      symbol
        .getDeclarations()
        .flatMap((decl) => ts.getJSDocCommentsAndTags(decl.compilerNode))
        .forEach(visitJSDocTags);

      if (routerRoute != null) routes.push(routerRoute);
      if (routerResource != null) resources.push(routerResource);
    });
  }

  project.getSourceFiles().forEach(visitRouterNodes);
  return {resources, routes, appRoot, gqlContext};
}

function zodSchemaOfType(tc: ts.TypeChecker, t: ts.Type): string {
  if (t.getFlags() & TypeFlags.String) {
    return `z.pipe(z.string(), z.transform(decodeURIComponent))`;
  } else if (t.getFlags() & TypeFlags.Number) {
    return `z.coerce.number<number>()`;
  } else if (t.getFlags() & TypeFlags.Null) {
    return `z.preprocess(s => s == null ? undefined : s, z.undefined())`;
  } else if (t.isUnion()) {
    const isRepresentingOptional =
      t.types.length === 2 &&
      t.types.some((s) => s.getFlags() & TypeFlags.Null);

    if (isRepresentingOptional) {
      const nonOptionalType = t.types.find(
        (s) => !(s.getFlags() & TypeFlags.Null),
      )!;

      return `z.pipe(z.nullish(${zodSchemaOfType(tc, nonOptionalType)}), z.transform(s => s == null ? undefined : s))`;
    } else {
      return `z.union([${t.types.map((it) => zodSchemaOfType(tc, it)).join(', ')}])`;
    }
  } else if (tc.isArrayLikeType(t)) {
    const typeArg = tc.getTypeArguments(t as ts.TypeReference)[0];
    const argZodSchema =
      typeArg == null ? `z.any()` : zodSchemaOfType(tc, typeArg);

    return `z.array(${argZodSchema})`;
  } else {
    logger.warn('Could not handle type:', tc.typeToString(t));
    return `z.any()`;
  }
}

async function generateRouter(project: Project, metadata: PastoriaMetadata) {
  const routerTemplate = await loadRouterTemplates(project, 'router.tsx');
  const tc = project.getTypeChecker().compilerObject;

  const routerConf = routerTemplate
    .getVariableDeclarationOrThrow('ROUTER_CONF')
    .getInitializerIfKindOrThrow(SyntaxKind.AsExpression)
    .getExpressionIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

  routerConf.getPropertyOrThrow('noop').remove();

  let entryPointImportIndex = 0;
  for (const {routeName, sourceFile, symbol, params} of metadata.routes) {
    const importAlias = `e${entryPointImportIndex++}`;
    const filePath = path.relative(process.cwd(), sourceFile.getFilePath());
    const moduleSpecifier = routerTemplate.getRelativePathAsModuleSpecifierTo(
      sourceFile.getFilePath(),
    );

    routerTemplate.addImportDeclaration({
      moduleSpecifier,
      namedImports: [
        {
          name: symbol.getName(),
          alias: importAlias,
        },
      ],
    });

    routerConf.addPropertyAssignment({
      name: `"${routeName}"`,
      initializer: (writer) => {
        writer
          .write('{')
          .indent(() => {
            writer.writeLine(`entrypoint: ${importAlias},`);
            if (params.size === 0) {
              writer.writeLine(`schema: z.object({})`);
            } else {
              writer.writeLine(`schema: z.object({`);
              for (const [paramName, paramType] of Array.from(params)) {
                writer.writeLine(
                  `  ${paramName}: ${zodSchemaOfType(tc, paramType)},`,
                );
              }

              writer.writeLine('})');
            }
          })
          .write('} as const');
      },
    });

    logger.info(
      `Created route ${pc.cyan(routeName)} for ${pc.green(symbol.getName())} exported from ${pc.yellow(filePath)}`,
    );
  }

  await routerTemplate.save();
}

async function generateJsResource(
  project: Project,
  metadata: PastoriaMetadata,
) {
  const jsResourceTemplate = await loadRouterTemplates(
    project,
    'js_resource.ts',
  );

  const resourceConf = jsResourceTemplate
    .getVariableDeclarationOrThrow('RESOURCE_CONF')
    .getInitializerIfKindOrThrow(SyntaxKind.AsExpression)
    .getExpressionIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

  resourceConf.getPropertyOrThrow('noop').remove();
  for (const {resourceName, sourceFile, symbol} of metadata.resources) {
    const filePath = path.relative(process.cwd(), sourceFile.getFilePath());
    const moduleSpecifier =
      jsResourceTemplate.getRelativePathAsModuleSpecifierTo(
        sourceFile.getFilePath(),
      );

    resourceConf.addPropertyAssignment({
      name: `"${resourceName}"`,
      initializer: (writer) => {
        writer.block(() => {
          writer
            .writeLine(`src: "${filePath}",`)
            .writeLine(
              `loader: () => import("${moduleSpecifier}").then(m => m.${symbol.getName()})`,
            );
        });
      },
    });

    logger.info(
      `Created resource ${pc.cyan(resourceName)} for ${pc.green(symbol.getName())} exported from ${pc.yellow(filePath)}`,
    );
  }

  await jsResourceTemplate.save();
}

async function generateAppRoot(project: Project, metadata: PastoriaMetadata) {
  const targetDir = process.cwd();
  const appRoot: AppRoot | null = metadata.appRoot;

  if (appRoot == null) {
    return;
  }

  const appRootSourceFile: SourceFile = appRoot.sourceFile;
  const appRootSymbol: Symbol = appRoot.symbol;
  const filePath = path.relative(targetDir, appRootSourceFile.getFilePath());
  const appRootFile = project.createSourceFile(
    '__generated__/router/app_root.ts',
    '',
    {
      overwrite: true,
    },
  );

  const moduleSpecifier = appRootFile.getRelativePathAsModuleSpecifierTo(
    appRootSourceFile.getFilePath(),
  );

  appRootFile.addStatements(`/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 */

export {${appRootSymbol.getName()} as App} from '${moduleSpecifier}';
`);

  await appRootFile.save();

  logger.info(
    `Created app root for ${pc.green(appRootSymbol.getName())} exported from ${pc.yellow(filePath)}`,
  );
}

async function generateGraphqlContext(
  project: Project,
  metadata: PastoriaMetadata,
) {
  const targetDir = process.cwd();
  const gqlContext: GqlContext | null = metadata.gqlContext;
  const contextFile = project.createSourceFile(
    '__generated__/router/context.ts',
    '',
    {
      overwrite: true,
    },
  );

  if (gqlContext != null) {
    const contextSourceFile: SourceFile = gqlContext.sourceFile;
    const contextSymbol: Symbol = gqlContext.symbol;
    const filePath = path.relative(targetDir, contextSourceFile.getFilePath());
    const moduleSpecifier = contextFile.getRelativePathAsModuleSpecifierTo(
      contextSourceFile.getFilePath(),
    );

    contextFile.addStatements(`/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 */

export {${contextSymbol.getName()} as Context} from '${moduleSpecifier}';
`);

    logger.info(
      `Created GraphQL context for ${pc.green(contextSymbol.getName())} exported from ${pc.yellow(filePath)}`,
    );
  } else {
    contextFile.addStatements(`/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 */

import {PastoriaRootContext} from 'pastoria-runtime/server';

/**
 * @gqlContext
 */
export class Context extends PastoriaRootContext {}
`);

    logger.info(
      `No @gqlContext found, generating default ${pc.green('Context')}`,
    );
  }

  await contextFile.save();
}

export async function generatePastoriaArtifacts() {
  const targetDir = process.cwd();
  const project = new Project({
    tsConfigFilePath: path.join(targetDir, 'tsconfig.json'),
  });

  const metadata = collectPastoriaMetadata(project);

  await generateAppRoot(project, metadata);
  await generateGraphqlContext(project, metadata);
  await generateRouter(project, metadata);
  await generateJsResource(project, metadata);
}
