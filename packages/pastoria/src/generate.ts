/**
 * @fileoverview Router Code Generator
 *
 * This script generates type-safe router configuration files by scanning TypeScript
 * source code for JSDoc annotations. It's part of the "Pastoria" routing framework.
 *
 * How it works:
 * 1. Scans all TypeScript files in the project for exported functions/classes
 * 2. Looks for JSDoc tags: @route, @resource, @appRoot, and @param
 * 3. Looks for exported classes that extend PastoriaRootContext for GraphQL context
 * 4. Generates files from templates:
 *    - js_resource.ts: Resource configuration for lazy loading
 *    - router.tsx: Client-side router with type-safe routes
 *    - app_root.ts: Re-export of the app root component (if @appRoot is found)
 *    - context.ts: Re-export of user's context class, or generate a default one
 *
 * Usage:
 * - Add @route <route-name> to functions to create routes
 * - Add @param <name> <type> to document route parameters
 * - Add @resource <resource-name> to exports for lazy loading
 * - Add @appRoot to a component to designate it as the application root wrapper
 * - Add @gqlContext to a class extending PastoriaRootContext to provide a custom GraphQL context
 * - Add @serverRoute to functions to add an express handler
 *
 * The generator automatically creates Zod schemas for route parameters based on
 * TypeScript types, enabling runtime validation and type safety.
 */

import {createHash} from 'node:crypto';
import * as path from 'node:path';
import pc from 'picocolors';
import * as prettier from 'prettier';
import {
  CodeBlockWriter,
  Project,
  SourceFile,
  Symbol,
  SyntaxKind,
  ts,
  TypeFlags,
  VariableDeclarationKind,
} from 'ts-morph';
import {logger, logInfo, logWarn} from './logger.js';

/**
 * Regex to extract the checksum from a generated file's header comment.
 * Matches: @generated-checksum <hex-hash>
 */
const CHECKSUM_REGEX = /@generated-checksum ([a-f0-9]+)/;

/**
 * Computes a SHA-256 checksum of the given content.
 */
function computeChecksum(content: string): string {
  return createHash('sha256').update(content).digest('hex');
}

/**
 * Extracts the checksum from a file's content, if present.
 */
function extractChecksum(content: string): string | null {
  const match = content.match(CHECKSUM_REGEX);
  return match?.[1] ?? null;
}

/**
 * Saves a source file to disk only if its content has changed.
 * Adds a checksum to the file header to enable fast comparison on subsequent runs.
 * Returns true if the file was written, false if skipped due to unchanged content.
 */
async function saveWithChecksum(sourceFile: SourceFile): Promise<boolean> {
  const filePath = sourceFile.getFilePath();

  // Get the generated content (without checksum line yet)
  const rawGeneratedContent = sourceFile.getFullText();
  const generatedContent = await prettier.format(rawGeneratedContent, {
    parser: 'typescript',
    singleQuote: true,
  });

  // Compute checksum of the content
  const newChecksum = computeChecksum(generatedContent);

  // Try to read the existing file and extract its checksum
  let existingChecksum: string | null = null;
  try {
    const existingContent = await sourceFile
      .getProject()
      .getFileSystem()
      .readFile(filePath);
    existingChecksum = extractChecksum(existingContent);
  } catch {
    // File doesn't exist yet, will need to write
  }

  // If checksums match, skip writing
  if (existingChecksum === newChecksum) {
    return false;
  }

  // Insert the checksum into the header comment
  // The header comment is the first thing in the file, we insert the checksum on line 2
  const contentWithChecksum = generatedContent.replace(
    '* This file was generated by `pastoria`.',
    `* This file was generated by \`pastoria\`.\n * @generated-checksum ${newChecksum}`,
  );

  // Update the source file content and save
  sourceFile.replaceWithText(contentWithChecksum);
  await sourceFile.save();

  return true;
}

interface ExportedSymbol {
  sourceFile: SourceFile;
  symbol: Symbol;
}

interface RouterResource extends ExportedSymbol {
  queries: Map<string, string>;
  entryPoints: Map<string, string>;
}

interface RouterRoute extends ExportedSymbol {
  params: Map<string, ts.Type>;
}

/**
 * A Pastoria API routes, defined as a default export in a route.ts file.
 */
interface ServerRoute extends ExportedSymbol {
  /**
   * Name of the route as defined relative to pastoria/.
   *
   * For example, /api/greet/[name].
   */
  routeName: string;
  /**
   * Express-style path for the route.
   *
   * For example, /api/greet/:name
   */
  routePath: string;
}

export interface PastoriaMetadata {
  /** Planned for future removal. */
  resources: Map<string, RouterResource>;
  /** Planned for future removal. */
  routes: Map<string, RouterRoute>;
  serverRoutes: ServerRoute[];
  entryPointRoutes: ServerRoute[];
}

// Regex to quickly check if a file contains any Pastoria JSDoc tags
export const PASTORIA_TAG_REGEX = /@(route|resource|param)\b/;

function collectQueryParameters(
  project: Project,
  queries: string[],
): Map<string, ts.Type> {
  const vars = new Map<string, ts.Type>();

  for (const query of queries) {
    const variablesType = project
      .getSourceFile(`__generated__/queries/${query}.graphql.ts`)
      ?.getExportedDeclarations()
      .get(`${query}$variables`)
      ?.at(0)
      ?.getType();

    if (variablesType == null) continue;

    for (const property of variablesType.getProperties()) {
      // TODO: Detect conflicting types among properties declared.
      const propertyName = property.getName();
      const propertyType = property.getValueDeclaration()?.getType();

      if (propertyType) {
        vars.set(propertyName, propertyType.compilerType);
      }
    }
  }

  return vars;
}

function collectServerRoutes(project: Project): ServerRoute[] {
  const serverRoutes: ServerRoute[] = [];

  function visitSourceFile(sourceFile: SourceFile) {
    if (sourceFile.getBaseName() !== 'route.ts') return;

    const defaultExport = sourceFile.getDefaultExportSymbol();
    if (defaultExport == null) return;

    const routeName = project
      .getDirectory('pastoria')
      ?.getRelativePathTo(sourceFile.getDirectory());

    if (!routeName) return;

    serverRoutes.push({
      routeName: '/' + routeName,
      routePath: '/' + routeName.replace(/\[(\w+)\]/g, ':$1'),
      sourceFile,
      symbol: defaultExport,
    });
  }

  project.getSourceFiles('pastoria/**').forEach(visitSourceFile);
  return serverRoutes;
}

function collectEntryPointRoutes(project: Project): ServerRoute[] {
  const routes: ServerRoute[] = [];

  function visitSourceFile(sourceFile: SourceFile) {
    if (sourceFile.getBaseName() !== 'page.tsx') return;

    const defaultExport = sourceFile.getDefaultExportSymbol();
    if (defaultExport == null) return;

    const routeName = project
      .getDirectory('pastoria')
      ?.getRelativePathTo(sourceFile.getDirectory());

    if (!routeName) return;

    routes.push({
      routeName: '/' + routeName,
      routePath: '/' + routeName.replace(/\[(\w+)\]/g, ':$1'),
      sourceFile,
      symbol: defaultExport,
    });
  }

  project.getSourceFiles('pastoria/**').forEach(visitSourceFile);
  return routes;
}

function collectPastoriaMetadata(
  project: Project,
  projectDir: string,
): PastoriaMetadata {
  const resources = new Map<string, RouterResource>();
  const routes = new Map<string, RouterRoute>();

  function visitRouterNodes(sourceFile: SourceFile) {
    // Skip generated files
    if (sourceFile.getFilePath().includes('__generated__')) {
      return;
    }

    // Skip files that don't contain any Pastoria JSDoc tags
    const fileText = sourceFile.getFullText();
    if (!PASTORIA_TAG_REGEX.test(fileText)) {
      return;
    }

    sourceFile.getExportSymbols().forEach((symbol) => {
      let routerResource = null as [string, RouterResource] | null;
      let routerRoute = null as [string, RouterRoute] | null;
      const routeParams = new Map<string, ts.Type>();

      function visitJSDocTags(tag: ts.JSDoc | ts.JSDocTag) {
        if (ts.isJSDoc(tag)) {
          tag.tags?.forEach(visitJSDocTags);
        } else if (ts.isJSDocParameterTag(tag)) {
          const typeNode = tag.typeExpression?.type;
          const tc = project.getTypeChecker().compilerObject;

          const type =
            typeNode == null
              ? tc.getUnknownType()
              : tc.getTypeFromTypeNode(typeNode);

          routeParams.set(tag.name.getText(), type);
        } else if (typeof tag.comment === 'string') {
          switch (tag.tagName.getText()) {
            case 'route': {
              routerRoute = [
                tag.comment,
                {sourceFile, symbol, params: routeParams},
              ];
              break;
            }
            case 'resource': {
              routerResource = [
                tag.comment,
                {
                  sourceFile,
                  symbol,
                  queries: new Map(),
                  entryPoints: new Map(),
                },
              ];
              break;
            }
          }
        }
      }

      symbol
        .getDeclarations()
        .flatMap((decl) => ts.getJSDocCommentsAndTags(decl.compilerNode))
        .forEach(visitJSDocTags);

      if (routerRoute != null) {
        const [routeName, routeSymbol] = routerRoute;
        const existing = routes.get(routeName);
        if (existing) {
          const existingFile = path.relative(
            projectDir,
            existing.sourceFile.getFilePath(),
          );
          const newFile = path.relative(
            projectDir,
            routeSymbol.sourceFile.getFilePath(),
          );
          logWarn(
            `Duplicate @route ${pc.cyan(routeName)}: defined in both ${pc.yellow(existingFile)} and ${pc.yellow(newFile)}. Using the latter.`,
          );
        }
        routes.set(routeName, routeSymbol);

        const {entryPoints, queries} = getResourceQueriesAndEntryPoints(
          routeSymbol.symbol,
        );

        if (routerResource == null && (entryPoints.size || queries.size)) {
          resources.set(`route(${routeName})`, {
            ...routeSymbol,
            entryPoints,
            queries,
          });
        }
      }

      if (routerResource != null) {
        const [resourceName, resourceSymbol] = routerResource;
        const {entryPoints, queries} = getResourceQueriesAndEntryPoints(
          resourceSymbol.symbol,
        );

        resourceSymbol.queries = queries;
        resourceSymbol.entryPoints = entryPoints;
        resources.set(resourceName, resourceSymbol);
      }
    });
  }

  project.getSourceFiles().forEach(visitRouterNodes);

  const serverRoutes = collectServerRoutes(project);
  const entryPointRoutes = collectEntryPointRoutes(project);

  // Warn about conflicts between @route definitions and page.tsx entrypoints
  for (const epRoute of entryPointRoutes) {
    const existing = routes.get(epRoute.routeName);
    if (existing) {
      const existingFile = path.relative(
        projectDir,
        existing.sourceFile.getFilePath(),
      );
      const newFile = path.relative(
        projectDir,
        epRoute.sourceFile.getFilePath(),
      );
      logWarn(
        `Duplicate route ${pc.cyan(epRoute.routeName)}: defined via @route in ${pc.yellow(existingFile)} and via page.tsx in ${pc.yellow(newFile)}. The page.tsx definition will take precedence.`,
      );
    }
  }

  return {resources, routes, serverRoutes, entryPointRoutes};
}

function getResourceQueriesAndEntryPoints(symbol: Symbol): {
  queries: Map<string, string>;
  entryPoints: Map<string, string>;
} {
  const resource = {
    queries: new Map<string, string>(),
    entryPoints: new Map<string, string>(),
  };

  const decl = symbol.getValueDeclaration();
  if (!decl) return resource;

  const t = decl.getType();
  const aliasSymbol = t.getAliasSymbol();

  if (aliasSymbol?.getName() === 'EntryPointComponent') {
    const [queries, entryPoints] = t.getAliasTypeArguments();

    queries?.getProperties().forEach((prop) => {
      const queryRef = prop.getName();
      const queryName = prop
        .getValueDeclaration()
        ?.getType()
        .getAliasSymbol()
        ?.getName();

      if (queryName) {
        resource.queries.set(queryRef, queryName);
      }
    });

    entryPoints?.getProperties().forEach((prop) => {
      const epRef = prop.getName();
      const entryPointTypeRef = prop
        .getValueDeclaration()
        ?.asKind(SyntaxKind.PropertySignature)
        ?.getTypeNode()
        ?.asKind(SyntaxKind.TypeReference);

      const entryPointTypeName = entryPointTypeRef?.getTypeName().getText();
      if (entryPointTypeName !== 'EntryPoint') {
        // TODO: Warn about found types not named EntryPoint
        return;
      }

      const entryPointInner = entryPointTypeRef?.getTypeArguments().at(0);
      const moduleTypeRef = entryPointInner?.asKind(SyntaxKind.TypeReference);
      if (moduleTypeRef != null) {
        const resourceName = moduleTypeRef
          ?.getTypeArguments()
          .at(0)
          ?.asKind(SyntaxKind.LiteralType)
          ?.getLiteral()
          .asKind(SyntaxKind.StringLiteral)
          ?.getLiteralText();

        if (resourceName) {
          resource.entryPoints.set(epRef, resourceName);
        }
      }
    });
  }

  return resource;
}

function zodSchemaOfType(
  sf: SourceFile,
  tc: ts.TypeChecker,
  t: ts.Type,
): string {
  if (t.aliasSymbol) {
    const decl = t.aliasSymbol.declarations?.at(0);
    if (decl == null) {
      logWarn('Could not handle type:', tc.typeToString(t));
      return `z.any()`;
    } else {
      const importPath = sf.getRelativePathAsModuleSpecifierTo(
        decl.getSourceFile().fileName,
      );

      return `z.transform((s: string) => s as import('${importPath}').${t.aliasSymbol.getName()})`;
    }
  } else if (t.getFlags() & TypeFlags.String) {
    return `z.pipe(z.string(), z.transform(decodeURIComponent))`;
  } else if (t.getFlags() & TypeFlags.Number) {
    return `z.coerce.number<number>()`;
  } else if (t.getFlags() & TypeFlags.Null) {
    return `z.preprocess(s => s == null ? undefined : s, z.undefined())`;
  } else if (t.isUnion()) {
    const nullishTypes: ts.Type[] = [];
    const nonNullishTypes: ts.Type[] = [];
    for (const s of t.types) {
      const flags = s.getFlags();
      if (flags & TypeFlags.Null || flags & TypeFlags.Undefined) {
        nullishTypes.push(s);
      } else {
        nonNullishTypes.push(s);
      }
    }

    if (nullishTypes.length > 0 && nonNullishTypes.length > 0) {
      const nonOptionalType = t.getNonNullableType();
      return `z.pipe(z.nullish(${zodSchemaOfType(sf, tc, nonOptionalType)}), z.transform(s => s == null ? undefined : s))`;
    } else {
      return `z.union([${t.types.map((it) => zodSchemaOfType(sf, tc, it)).join(', ')}])`;
    }
  } else if (tc.isArrayLikeType(t)) {
    const typeArg = tc.getTypeArguments(t as ts.TypeReference)[0];
    const argZodSchema =
      typeArg == null ? `z.any()` : zodSchemaOfType(sf, tc, typeArg);

    return `z.array(${argZodSchema})`;
  } else {
    logWarn('Could not handle type:', tc.typeToString(t));
    return `z.any()`;
  }
}

function writeEntryPoint(
  writer: CodeBlockWriter,
  project: Project,
  metadata: PastoriaMetadata,
  consumedQueries: Set<string>,
  resourceName: string,
  resource: RouterResource,
  parseVars = true,
) {
  writer.writeLine(`root: JSResource.fromModuleId('${resourceName}'),`);

  writer
    .write(`getPreloadProps(${parseVars ? '{params, schema}' : ''})`)
    .block(() => {
      if (parseVars) {
        writer.writeLine('const variables = schema.parse(params);');
      }

      writer.write('return').block(() => {
        writer
          .write('queries:')
          .block(() => {
            for (const [queryRef, query] of resource.queries.entries()) {
              consumedQueries.add(query);

              // Determine which variables this specific query needs
              const queryVars = collectQueryParameters(project, [query]);
              const hasVariables = queryVars.size > 0;

              writer
                .write(`${queryRef}:`)
                .block(() => {
                  writer.writeLine(`parameters: ${query}Parameters,`);

                  if (hasVariables) {
                    const varNames = Array.from(queryVars.keys());
                    // Always pick from the variables object
                    writer.write(`variables: {`);
                    writer.write(
                      varNames.map((v) => `${v}: variables.${v}`).join(', '),
                    );
                    writer.write(`}`);
                  } else {
                    // Query has no variables, pass empty object
                    writer.write(`variables: {}`);
                  }
                  writer.newLine();
                })
                .write(',');
            }
          })
          .writeLine(',');

        writer.write('entryPoints:').block(() => {
          for (const [
            epRef,
            subresourceName,
          ] of resource.entryPoints.entries()) {
            const subresource = metadata.resources.get(subresourceName);
            if (subresource) {
              writer
                .write(`${epRef}:`)
                .block(() => {
                  writer.writeLine(`entryPointParams: {},`);
                  writer.write('entryPoint:').block(() => {
                    writeEntryPoint(
                      writer,
                      project,
                      metadata,
                      consumedQueries,
                      subresourceName,
                      subresource,
                      false,
                    );
                  });
                })
                .writeLine(',');
            }
          }
        });
      });
    });
}

function escapeRouteName(routeName: string): string {
  return routeName
    .replace(/\[(\w+)\]/g, '$$$1')
    .replace(/\//g, '_')
    .replace(/^_/, '')
    .replace(/_$/, '');
}

function getSchemaCode(
  pageSourceFile: SourceFile,
  targetSourceFile: SourceFile,
  tc: ts.TypeChecker,
  params: Map<string, ts.Type>,
): string {
  // Try to copy schema from page.tsx if it exists
  const schemaDecl = pageSourceFile
    .getExportedDeclarations()
    .get('schema')
    ?.at(0);

  if (schemaDecl?.isKind(SyntaxKind.VariableDeclaration)) {
    const initializer = schemaDecl.getInitializer();
    if (initializer) {
      return initializer.getText();
    }
  }

  // Fallback: generate from query variable types
  if (params.size === 0) {
    return 'z.object({})';
  }

  const properties = Array.from(params)
    .map(
      ([name, type]) =>
        `${name}: ${zodSchemaOfType(targetSourceFile, tc, type)}`,
    )
    .join(', ');

  return `z.object({${properties}})`;
}

export class PastoriaExecutionContext {
  static TEMPLATES_DIRECTORY = path.join(import.meta.dirname, '../templates');

  private readonly metadata: PastoriaMetadata;

  constructor(
    private readonly project: Project,
    private readonly templatesDir = PastoriaExecutionContext.TEMPLATES_DIRECTORY,
    private readonly projectDir = process.cwd(),
  ) {
    this.metadata = collectPastoriaMetadata(project, projectDir);
  }

  private async loadRouterTemplate(filename: string) {
    const templatePath = path.join(this.templatesDir, filename);
    const outputPath = path.join('__generated__/router', filename);

    const template = await this.getFileSystem().readFile(templatePath);
    const warningComment = `/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly. Instead, edit the template at ${path.basename(templatePath)}.
 */

`;

    return this.project.createSourceFile(
      outputPath,
      warningComment + template,
      {
        overwrite: true,
      },
    );
  }

  private getTypeChecker() {
    return this.project.getTypeChecker().compilerObject;
  }

  private getFileSystem() {
    return this.project.getFileSystem();
  }

  private relativePathTo(sourceFile: SourceFile) {
    return path.relative(this.projectDir, sourceFile.getFilePath());
  }

  async generatePastoriaArtifacts() {
    // TODO: Add sanity checks that #pastoria/app.tsx and #pastoria/environment.ts exist.
    await this.generateRouter();
    await this.generateJsResource();
    await this.generateServer();
    await this.generateEntryPointFiles();
  }

  private async generateRouter() {
    const {entryPointRoutes, routes, resources} = this.metadata;
    const routerTemplate = await this.loadRouterTemplate('router.tsx');
    const tc = this.getTypeChecker();

    let didAddJsResourceImport = false;
    const routerConf = routerTemplate
      .getVariableDeclarationOrThrow('ROUTER_CONF')
      .getInitializerIfKindOrThrow(SyntaxKind.AsExpression)
      .getExpressionIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

    const routeMapping = routerTemplate
      .getVariableDeclarationOrThrow('ROUTE_MAPPING')
      .getInitializerIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

    routerConf.getPropertyOrThrow('noop').remove();

    if (entryPointRoutes.length > 0) {
      routerTemplate.addStatements(`
declare global {
  type PastoriaRouteName =
    ${entryPointRoutes.map((r) => `| '${r.routeName}'`).join('    \n')};

  type PastoriaPageQueries = {
    ${entryPointRoutes.map((r) => `['${r.routeName}']: ${escapeRouteName(r.routeName)}_EP_Queries`)},
  };

  type PastoriaPageEntryPoints = {
    ${entryPointRoutes.map((r) => `['${r.routeName}']: ${escapeRouteName(r.routeName)}_EP_EntryPoints`)},
  };

  type PastoriaPageProps<T extends PastoriaRouteName> = EntryPointProps<
    PastoriaPageQueries[T],
    PastoriaPageEntryPoints[T],
    {},
    {}
  >
}
`);
    }

    let entryPointImportIndex = 0;
    for (let [routeName, {sourceFile, symbol, params}] of routes.entries()) {
      const filePath = this.relativePathTo(sourceFile);
      let entryPointExpression: string;

      // Resource-routes are combined declarations of a resource and a route
      // where we should generate the entrypoint for the route.
      const isResourceRoute = Array.from(resources.entries()).find(
        ([, {symbol: resourceSymbol}]) => symbol === resourceSymbol,
      );

      if (isResourceRoute) {
        const [resourceName, resource] = isResourceRoute;
        const entryPointFunctionName = `entrypoint_${resourceName.replace(/\W/g, '')}`;

        if (!didAddJsResourceImport) {
          didAddJsResourceImport = true;
          routerTemplate.addImportDeclaration({
            moduleSpecifier: './js_resource',
            namedImports: ['JSResource', 'ModuleType'],
          });
        }

        const consumedQueries = new Set<string>();
        routerTemplate.addFunction({
          name: entryPointFunctionName,
          returnType: `EntryPoint<ModuleType<'${resourceName}'>, EntryPointParams<'${routeName}'>>`,
          statements: (writer) => {
            writer.write('return ').block(() => {
              writeEntryPoint(
                writer,
                this.project,
                this.metadata,
                consumedQueries,
                resourceName,
                resource,
              );
            });
          },
        });

        if (params.size === 0 && consumedQueries.size > 0) {
          params = collectQueryParameters(
            this.project,
            Array.from(consumedQueries),
          );
        }

        for (const query of consumedQueries) {
          routerTemplate.addImportDeclaration({
            moduleSpecifier: `#genfiles/queries/${query}$parameters`,
            defaultImport: `${query}Parameters`,
          });
        }

        entryPointExpression = entryPointFunctionName + '()';
      } else {
        const importAlias = `e${entryPointImportIndex++}`;
        const moduleSpecifier =
          routerTemplate.getRelativePathAsModuleSpecifierTo(
            sourceFile.getFilePath(),
          );

        routerTemplate.addImportDeclaration({
          moduleSpecifier,
          namedImports: [
            {
              name: symbol.getName(),
              alias: importAlias,
            },
          ],
        });

        entryPointExpression = importAlias;
      }

      routerConf.addPropertyAssignment({
        name: `"${routeName}"`,
        initializer: (writer) => {
          writer
            .write('{')
            .indent(() => {
              writer.writeLine(`entrypoint: ${entryPointExpression},`);
              if (params.size === 0) {
                writer.writeLine(`schema: z.object({})`);
              } else {
                writer.writeLine(`schema: z.object({`);
                for (const [paramName, paramType] of Array.from(params)) {
                  writer.writeLine(
                    `  ${paramName}: ${zodSchemaOfType(routerTemplate, tc, paramType)},`,
                  );
                }

                writer.writeLine('})');
              }
            })
            .write('} as const');
        },
      });

      routeMapping.addPropertyAssignment({
        name: `"${routeName}"`,
        initializer: `ROUTER_CONF["${routeName}"]`,
      });

      logInfo(
        'Created route',
        pc.cyan(routeName),
        'for',
        pc.green(symbol.getName()),
        'exported from',
        pc.yellow(filePath),
      );
    }

    for (const {routeName, routePath} of entryPointRoutes) {
      const escapedRouteName = escapeRouteName(routeName);

      routerTemplate.addImportDeclaration({
        moduleSpecifier: `./${escapedRouteName}.entrypoint`,
        namedImports: [
          {
            name: 'schema',
            alias: `${escapedRouteName}_EP_schema`,
          },
          {
            name: 'entrypoint',
            alias: `${escapedRouteName}_EP_entrypoint`,
          },
          {
            name: 'Queries',
            alias: `${escapedRouteName}_EP_Queries`,
          },
          {
            name: 'EntryPoints',
            alias: `${escapedRouteName}_EP_EntryPoints`,
          },
        ],
      });

      routerConf.addPropertyAssignment({
        name: `"${routeName}"`,
        initializer: (writer) => {
          writer
            .write('{')
            .indent(() => {
              writer.writeLine(
                `entrypoint: ${escapedRouteName}_EP_entrypoint,`,
              );
              writer.writeLine(`schema: ${escapedRouteName}_EP_schema,`);
            })
            .write('} as const');
        },
      });

      routeMapping.addPropertyAssignment({
        name: `"${routePath}"`,
        initializer: `ROUTER_CONF["${routeName}"]`,
      });

      logInfo('Created route', pc.cyan(routeName));
    }

    await saveWithChecksum(routerTemplate);
  }

  private async generateJsResource() {
    const {resources, entryPointRoutes} = this.metadata;
    const jsResourceTemplate = await this.loadRouterTemplate('js_resource.ts');

    const resourceConf = jsResourceTemplate
      .getVariableDeclarationOrThrow('RESOURCE_CONF')
      .getInitializerIfKindOrThrow(SyntaxKind.AsExpression)
      .getExpressionIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

    resourceConf.getPropertyOrThrow('noop').remove();

    for (const [resourceName, {sourceFile, symbol}] of resources.entries()) {
      const filePath = this.relativePathTo(sourceFile);
      const moduleSpecifier =
        jsResourceTemplate.getRelativePathAsModuleSpecifierTo(
          sourceFile.getFilePath(),
        );

      resourceConf.addPropertyAssignment({
        name: `"${resourceName}"`,
        initializer: (writer) => {
          writer.block(() => {
            writer
              .writeLine(`src: "${filePath}",`)
              .writeLine(
                `loader: () => import("${moduleSpecifier}").then(m => m.${symbol.getName()})`,
              );
          });
        },
      });

      logInfo(
        'Created resource',
        pc.cyan(resourceName),
        'for',
        pc.green(symbol.getName()),
        'exported from',
        pc.yellow(filePath),
      );
    }

    for (const {routeName} of entryPointRoutes) {
      resourceConf.addPropertyAssignment({
        name: `"route(${routeName})"`,
        initializer: (writer) => {
          writer.block(() => {
            writer.writeLine(`src: "pastoria${routeName}/page.tsx",`);
            writer.writeLine(
              `loader: () => import("#pastoria${routeName}/page").then(m => m.default),`,
            );
          });
        },
      });
    }

    await saveWithChecksum(jsResourceTemplate);
  }

  private async generateServer() {
    const {serverRoutes} = this.metadata;
    const serverTemplate = await this.loadRouterTemplate('server.ts');

    let serverHandlerImportIndex = 0;
    for (const {symbol, sourceFile, routeName, routePath} of serverRoutes) {
      const importAlias = `e${serverHandlerImportIndex++}`;
      const filePath = this.relativePathTo(sourceFile);
      const moduleSpecifier = serverTemplate.getRelativePathAsModuleSpecifierTo(
        sourceFile.getFilePath(),
      );

      serverTemplate.addImportDeclaration({
        moduleSpecifier,
        namedImports: [{name: symbol.getName(), alias: importAlias}],
      });

      serverTemplate.addStatements(
        `router.use('${routePath}', ${importAlias})`,
      );

      logInfo(
        'Created server route',
        pc.cyan(routeName),
        'for',
        pc.yellow(filePath),
      );
    }

    await saveWithChecksum(serverTemplate);
  }

  private async generateEntryPointFiles() {
    const {entryPointRoutes} = this.metadata;
    const expectedFiles = new Set(
      entryPointRoutes.map(
        (route) => `${escapeRouteName(route.routeName)}.entrypoint.ts`,
      ),
    );

    for (const route of entryPointRoutes) {
      await this.generateSingleEntryPointFile(route);
    }

    // Delete stale entrypoint files that no longer correspond to a route
    const generatedDir = path.resolve(this.projectDir, '__generated__/router');
    try {
      const entries = this.getFileSystem().readDirSync(generatedDir);
      for (const entry of entries) {
        if (
          entry.isFile &&
          entry.name.endsWith('.entrypoint.ts') &&
          !expectedFiles.has(path.basename(entry.name))
        ) {
          this.getFileSystem().deleteSync(entry.name);
          logWarn(
            'Removed stale entrypoint',
            pc.cyan(path.basename(entry.name)),
          );
        }
      }
    } catch {
      // Directory may not exist yet on first run
    }
  }

  private async generateSingleEntryPointFile(route: ServerRoute) {
    const escapedRouteName = escapeRouteName(route.routeName);
    const resourceName = `route(${route.routeName})`;
    const fileName = `__generated__/router/${escapedRouteName}.entrypoint.ts`;

    // Create source file with header comment
    const warningComment = `/*
 * This file was generated by \`pastoria\`.
 * Do not modify this file directly.
 */

`;
    const sourceFile = this.project.createSourceFile(fileName, warningComment, {
      overwrite: true,
    });

    // Extract Queries type from page.tsx to get query names
    const queriesType = route.sourceFile
      .getExportedDeclarations()
      .get('Queries')
      ?.at(0)
      ?.getType();

    // Build queries map: {queryRef -> queryTypeName}
    const queries = new Map<string, string>();
    queriesType?.getProperties().forEach((prop) => {
      const queryName = prop
        .getValueDeclaration()
        ?.getType()
        .getAliasSymbol()
        ?.getName();
      if (queryName) {
        queries.set(prop.getName(), queryName);
      }
    });

    // Collect parameters from query variables
    const params = collectQueryParameters(
      this.project,
      Array.from(queries.values()),
    );

    const exportedDecls = route.sourceFile.getExportedDeclarations();
    const hasQueriesExport = exportedDecls.has('Queries');
    const hasEntryPointsExport = exportedDecls.has('EntryPoints');

    // Import only the types that are actually exported from page.tsx
    const pageTypeImports: string[] = [];
    if (hasEntryPointsExport) pageTypeImports.push('EntryPoints');
    if (hasQueriesExport) pageTypeImports.push('Queries');

    if (pageTypeImports.length > 0) {
      sourceFile.addImportDeclaration({
        moduleSpecifier: `#pastoria${route.routeName}/page`,
        namedImports: pageTypeImports,
        isTypeOnly: true,
      });
    }

    sourceFile.addImportDeclaration({
      moduleSpecifier: 'react-relay/hooks',
      namedImports: ['EntryPoint'],
    });

    sourceFile.addImportDeclaration({
      moduleSpecifier: 'zod/v4-mini',
      namedImports: ['z'],
    });

    sourceFile.addImportDeclaration({
      moduleSpecifier: './js_resource',
      namedImports: ['JSResource', 'ModuleType'],
    });

    // Generate schema - prefer copying from page.tsx if exported
    const tc = this.getTypeChecker();
    // TODO: Copy the original page file and remove everything but `schema` and the variables it uses.
    const schemaCode = getSchemaCode(route.sourceFile, sourceFile, tc, params);
    sourceFile.addVariableStatement({
      declarations: [
        {
          name: 'schema',
          initializer: schemaCode,
        },
      ],
      isExported: false,
      declarationKind: VariableDeclarationKind.Const,
    });

    // Build a RouterResource for writeEntryPoint
    const resource: RouterResource = {
      sourceFile: route.sourceFile,
      symbol: route.symbol,
      queries,
      entryPoints: new Map(),
    };

    // Generate entrypoint using writeEntryPoint
    const consumedQueries = new Set<string>();
    sourceFile.addVariableStatement({
      declarations: [
        {
          name: 'entrypoint',
          type: `EntryPoint<ModuleType<'${resourceName}'>, {params: Record<string, any>, schema: typeof schema}>`,
          initializer: (writer) => {
            writer.block(() => {
              writeEntryPoint(
                writer,
                this.project,
                this.metadata,
                consumedQueries,
                resourceName,
                resource,
              );
            });
          },
        },
      ],
      declarationKind: VariableDeclarationKind.Const,
    });

    // Add query parameter imports after writeEntryPoint populates consumedQueries
    for (const queryName of consumedQueries) {
      sourceFile.addImportDeclaration({
        moduleSpecifier: `#genfiles/queries/${queryName}$parameters`,
        defaultImport: `${queryName}Parameters`,
      });
    }

    // Generate fallback types for any missing exports
    if (!hasQueriesExport) {
      sourceFile.addStatements('type Queries = {};');
    }
    if (!hasEntryPointsExport) {
      sourceFile.addStatements('type EntryPoints = {};');
    }

    // Export statement
    sourceFile.addStatements(
      `\nexport {entrypoint, schema, type EntryPoints, type Queries};\n`,
    );

    await saveWithChecksum(sourceFile);
    logInfo('Created entrypoint', pc.cyan(route.routeName));
  }
}

export function generateClientEntry(): string {
  return `// Generated by Pastoria.
import {createRouterApp} from '#genfiles/router/router';
import App from '#pastoria/app';
import {hydrateRoot} from 'react-dom/client';

async function main() {
  const RouterApp = await createRouterApp();
  hydrateRoot(document, <RouterApp App={App} />);
}

main();
`;
}

export function generateServerEntry(): string {
  return `// Generated by Pastoria.
import {JSResource} from '#genfiles/router/js_resource';
import {
  listRoutes,
  router__createAppFromEntryPoint,
  router__loadEntryPoint,
} from '#genfiles/router/router';
import {router as serverRouter} from '#genfiles/router/server';
import App from '#pastoria/app';
import environment from '#pastoria/environment';
import express from 'express';
import {createRouterHandler} from 'pastoria-runtime/server';
import type {Manifest} from 'vite';

export function createHandler(
  persistedQueries: Record<string, string>,
  manifest?: Manifest,
) {
  const routeHandler = createRouterHandler(
    listRoutes(),
    JSResource.srcOfModuleId,
    router__loadEntryPoint,
    router__createAppFromEntryPoint,
    App,
    environment,
    persistedQueries,
    manifest,
  );

  const router = express.Router();
  router.use(routeHandler);
  router.use(serverRouter)

  return router;
}
`;
}
