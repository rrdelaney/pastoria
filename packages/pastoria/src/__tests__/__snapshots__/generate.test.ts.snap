// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`generatePastoriaArtifacts > dynamic page route with queries > generates a parameterized entrypoint with query variables 1`] = `
"/*
 * This file was generated by \`pastoria\`.
 * @generated-checksum <STRIPPED>
 * Do not modify this file directly.
 */
import type { Queries } from '../../pastoria/details/[name]/page';
import { EntryPoint } from 'react-relay/hooks';
import { z } from 'zod/v4-mini';
import { JSResource, ModuleType } from './js_resource';
import page_DetailsQueryParameters from '#genfiles/queries/page_DetailsQuery$parameters';

const schema = z.object({
  name: z.pipe(z.string(), z.transform(decodeURIComponent)),
});
const entrypoint: EntryPoint<
  ModuleType<'#pastoria/details/[name]/page'>,
  { params: Record<string, unknown> }
> = {
  root: JSResource.fromModuleId('#pastoria/details/[name]/page'),
  getPreloadProps({ params }) {
    const variables = schema.parse(params);
    return {
      queries: {
        details: {
          parameters: page_DetailsQueryParameters,
          variables: { name: variables.name },
        },
      },
      entryPoints: {},
    };
  },
};
type EntryPoints = {};

export { entrypoint, schema, type EntryPoints, type Queries };
"
`;

exports[`generatePastoriaArtifacts > empty project > generates router, js_resource, and server with empty configs 1`] = `
"/*
 * This file was generated by \`pastoria\`.
 * @generated-checksum <STRIPPED>
 * Do not modify this file directly. Instead, edit the template at router.tsx.
 */

import {
  AnyPreloadedEntryPoint,
  EnvironmentProvider,
  relayClientEnvironment,
  RouterOps,
} from 'pastoria-runtime';
import { createRouter } from 'radix3';
import {
  AnchorHTMLAttributes,
  createContext,
  PropsWithChildren,
  StrictMode,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useState,
} from 'react';
import { preinit, preloadModule } from 'react-dom';
import {
  EntryPoint,
  EntryPointContainer,
  EntryPointProps,
  loadEntryPoint,
  RelayEnvironmentProvider,
  useEntryPointLoader,
} from 'react-relay/hooks';
import * as z from 'zod/v4-mini';

type RouterConf = typeof ROUTER_CONF;
const ROUTER_CONF = {} as const;

export type RouteId = keyof RouterConf;
export type NavigationDirection = string | URL | ((nextUrl: URL) => void);

const ROUTE_MAPPING = {};

const ROUTER = createRouter<RouterConf[keyof RouterConf]>({
  routes: ROUTE_MAPPING,
});

class RouterLocation {
  private constructor(
    readonly pathname: string,
    readonly searchParams: URLSearchParams,
    readonly method?: 'push' | 'replace' | 'popstate',
  ) {}

  href() {
    if (this.searchParams.size > 0) {
      return this.pathname + '?' + this.searchParams.toString();
    }

    return this.pathname;
  }

  route() {
    return ROUTER.lookup(this.pathname);
  }

  params() {
    const matchedRoute = this.route();
    const params = {
      ...matchedRoute?.params,
      ...Object.fromEntries(this.searchParams),
    };

    if (matchedRoute?.schema) {
      return matchedRoute.schema.parse(params);
    } else {
      return params;
    }
  }

  static parse(path: string, method?: 'push' | 'replace' | 'popstate') {
    if (path.startsWith('/')) {
      path = 'router:' + path;
    }

    try {
      const nextUrl = new URL(path);
      return new RouterLocation(nextUrl.pathname, nextUrl.searchParams, method);
    } catch (_e) {
      return new RouterLocation(path, new URLSearchParams(), method);
    }
  }
}

function useLocation(initialPath?: string) {
  const [location, setLocation] = useState((): RouterLocation => {
    return RouterLocation.parse(initialPath ?? window.location.href);
  });

  useEffect(() => {
    function listener(e: PopStateEvent) {
      setLocation(RouterLocation.parse(window.location.href, 'popstate'));
    }

    window.addEventListener('popstate', listener);
    return () => {
      window.removeEventListener('popstate', listener);
    };
  }, []);

  useEffect(() => {
    if (location.method === 'push') {
      window.history.pushState({}, '', location.href());
      window.scrollTo(0, 0);
    } else if (location.method === 'replace') {
      window.history.replaceState({}, '', location.href());
    }
  }, [location]);

  return [location, setLocation] as const;
}

export function router__hydrateStore(provider: EnvironmentProvider) {
  const env = provider.getEnvironment(null);
  if ('__router_ops' in window) {
    const ops = (window as any).__router_ops as RouterOps;
    for (const [op, payload] of ops) {
      env.commitPayload(op, payload);
    }
  }
}

export async function router__loadEntryPoint(
  provider: EnvironmentProvider,
  initialPath?: string,
) {
  if (!initialPath) initialPath = window.location.href;
  const initialLocation = RouterLocation.parse(initialPath);
  const initialRoute = initialLocation.route();
  if (!initialRoute) return null;

  await initialRoute.entrypoint?.root.load();
  return loadEntryPoint(provider, initialRoute.entrypoint, {
    params: initialLocation.params(),
  });
}

interface RouterContextValue {
  location: RouterLocation;
  setLocation: React.Dispatch<React.SetStateAction<RouterLocation>>;
}

const RouterContext = createContext<RouterContextValue>({
  location: RouterLocation.parse('/'),
  setLocation: () => {},
});

const REACT_REFRESH_SCRIPT = \`
import RefreshRuntime from 'http://localhost:3000/@react-refresh'
RefreshRuntime.injectIntoGlobalHook(window)
window.$RefreshReg$ = () => {}
window.$RefreshSig$ = () => (type) => type
window.__vite_plugin_react_preamble_installed__ = true\`;

export function router__createAppFromEntryPoint(
  initialEntryPoint: AnyPreloadedEntryPoint | null,
  provider: EnvironmentProvider,
  initialPath?: string,
) {
  const env = provider.getEnvironment(null);

  function RouterShell({
    preloadModules,
    preloadStylesheets,
    children,
  }: PropsWithChildren<{
    preloadModules?: string[];
    preloadStylesheets?: string[];
  }>) {
    for (const m of preloadModules ?? []) {
      preloadModule(m, { as: 'script' });
    }

    for (const s of preloadStylesheets ?? []) {
      preinit(s, { as: 'style' });
    }

    return (
      <StrictMode>
        <RelayEnvironmentProvider environment={env}>
          <html>
            <head>
              <meta charSet="utf-8" />
              <meta
                name="viewport"
                content="width=device-width, initial-scale=1"
              />

              {process.env.NODE_ENV !== 'production' && (
                <script
                  type="module"
                  dangerouslySetInnerHTML={{ __html: REACT_REFRESH_SCRIPT }}
                />
              )}
            </head>

            <body>{children}</body>
          </html>
        </RelayEnvironmentProvider>
      </StrictMode>
    );
  }

  function RouterCore() {
    const [location, setLocation] = useLocation(initialPath);
    const routerContextValue = useMemo(
      (): RouterContextValue => ({
        location,
        setLocation,
      }),
      [location, setLocation],
    );

    const [entryPointRef, loadEntryPointRef, _dispose] = useEntryPointLoader(
      provider,
      location.route()?.entrypoint,
    );

    useEffect(() => {
      loadEntryPointRef({ params: location.params() });
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [location]);

    const entryPoint = entryPointRef ?? initialEntryPoint;
    if (entryPoint == null) return null;

    return (
      <RouterContext value={routerContextValue}>
        <EntryPointContainer entryPointReference={entryPoint} props={{}} />
      </RouterContext>
    );
  }

  function RouterApp(props: {
    preloadModules?: string[];
    preloadStylesheets?: string[];
    App?: React.ComponentType<PropsWithChildren<{}>> | null;
  }) {
    return (
      <RouterShell
        preloadModules={props.preloadModules}
        preloadStylesheets={props.preloadStylesheets}
      >
        {props.App == null ? (
          <RouterCore />
        ) : (
          <props.App children={<RouterCore />} />
        )}
      </RouterShell>
    );
  }

  return RouterApp;
}

export async function createRouterApp() {
  const provider = relayClientEnvironment;

  router__hydrateStore(provider);
  const ep = await router__loadEntryPoint(provider);
  return router__createAppFromEntryPoint(ep, provider);
}

export function usePath() {
  const { location } = useContext(RouterContext);
  return location.pathname;
}

export function useRouteParams<R extends RouteId>(
  routeId: R,
): z.infer<RouterConf[R]['schema']> {
  const schema = ROUTER_CONF[routeId].schema;
  const { location } = useContext(RouterContext);

  return schema.parse(location.params()) as z.infer<RouterConf[R]['schema']>;
}

function router__createPathForRoute(
  routeId: RouteId,
  inputParams: Record<string, any>,
): string {
  const schema = ROUTER_CONF[routeId].schema;
  const params = schema.parse(inputParams);

  let pathname = routeId as string;
  const searchParams = new URLSearchParams();

  Object.entries(params).forEach(([key, value]) => {
    if (value != null) {
      const paramPattern = \`:\${key}\`;
      if (pathname.includes(paramPattern)) {
        pathname = pathname.replace(
          paramPattern,
          encodeURIComponent(String(value)),
        );
      } else {
        searchParams.set(key, String(value));
      }
    }
  });

  if (searchParams.size > 0) {
    return pathname + '?' + searchParams.toString();
  } else {
    return pathname;
  }
}

function router__evaluateNavigationDirection(nav: NavigationDirection) {
  let nextUrl: URL;
  if (typeof nav === 'string') {
    nextUrl = new URL(nav, window.location.origin);
  } else if (nav instanceof URL) {
    nextUrl = nav;
  } else {
    nextUrl = new URL(window.location.href);
    nav(nextUrl);
  }

  if (window.location.origin !== nextUrl.origin) {
    throw new Error('Cannot navigate to a different origin.');
  }

  if (nextUrl.searchParams.size > 0) {
    return nextUrl.pathname + '?' + nextUrl.searchParams.toString();
  } else {
    return nextUrl.pathname;
  }
}

export function useNavigation() {
  const { setLocation } = useContext(RouterContext);

  return useMemo(() => {
    function push(nav: NavigationDirection) {
      setLocation(
        RouterLocation.parse(router__evaluateNavigationDirection(nav), 'push'),
      );
    }

    function replace(nav: NavigationDirection) {
      setLocation(
        RouterLocation.parse(
          router__evaluateNavigationDirection(nav),
          'replace',
        ),
      );
    }

    function pushRoute<R extends RouteId>(
      routeId: R,
      params: z.input<RouterConf[R]['schema']>,
    ) {
      setLocation(
        RouterLocation.parse(
          router__createPathForRoute(routeId, params),
          'push',
        ),
      );
    }

    function replaceRoute<R extends RouteId>(
      routeId: R,
      params: z.input<RouterConf[R]['schema']>,
    ) {
      setLocation((prevLoc) =>
        RouterLocation.parse(
          router__createPathForRoute(routeId, {
            ...prevLoc.params(),
            ...params,
          }),
          'replace',
        ),
      );
    }

    return { push, replace, pushRoute, replaceRoute } as const;
  }, [setLocation]);
}

export function Link({
  href,
  target,
  onClick,
  ...props
}: AnchorHTMLAttributes<HTMLAnchorElement>) {
  const { push } = useNavigation();

  const handleClick = useCallback(
    (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {
      onClick?.(e);
      if (e.defaultPrevented || !href) return;

      // See https://github.com/remix-run/react-router/blob/main/packages/react-router/lib/dom/dom.ts#L34
      const shouldHandle =
        e.button === 0 &&
        (!target || target === '_self') &&
        !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);

      if (!shouldHandle) return;

      const destination = new URL(href, window.location.href);
      if (destination.origin !== window.location.origin) return;

      e.preventDefault();
      push(destination);
    },
    [push, href, target, onClick],
  );

  return <a {...props} href={href} target={target} onClick={handleClick} />;
}

export interface LinkProps<R extends RouteId>
  extends AnchorHTMLAttributes<HTMLAnchorElement> {
  route: R;
  params: z.input<RouterConf[R]['schema']>;
  href?: never;
}

export function RouteLink<R extends RouteId>({
  route,
  params,
  ...props
}: PropsWithChildren<LinkProps<R>>) {
  const href = useMemo(
    () => router__createPathForRoute(route, params).toString(),
    [params, route],
  );

  return <Link {...props} href={href} />;
}

export function listRoutes() {
  return Object.keys(ROUTE_MAPPING);
}

export function getSchemaForRoute<R extends RouteId>(
  routeId: R,
): RouterConf[R]['schema'] {
  return ROUTER_CONF[routeId].schema;
}
"
`;

exports[`generatePastoriaArtifacts > empty project > generates router, js_resource, and server with empty configs 2`] = `
"/*
 * This file was generated by \`pastoria\`.
 * @generated-checksum <STRIPPED>
 * Do not modify this file directly. Instead, edit the template at js_resource.ts.
 */

import type { JSResourceReference } from 'react-relay/hooks';

type ResourceConf = typeof RESOURCE_CONF;
const RESOURCE_CONF = {} as const;

type ModuleId = keyof ResourceConf;
export type ModuleType<M extends ModuleId> = Awaited<
  ReturnType<ResourceConf[M]['loader']>
>;

export class JSResource<M extends ModuleId>
  implements JSResourceReference<ModuleType<M>>
{
  static srcOfModuleId(id: string): string | null {
    return RESOURCE_CONF[id as ModuleId].src;
  }

  private static readonly resourceCache = new Map<ModuleId, JSResource<any>>();
  static fromModuleId<M extends ModuleId>(moduleId: M) {
    if (JSResource.resourceCache.has(moduleId)) {
      return JSResource.resourceCache.get(moduleId)!;
    }

    const resource = new JSResource(moduleId);
    JSResource.resourceCache.set(moduleId, resource);
    return resource;
  }

  private constructor(private readonly moduleId: M) {}
  private modulePromiseCache: Promise<ModuleType<M>> | null = null;
  private moduleCache: ModuleType<M> | null = null;

  getModuleId(): string {
    return this.moduleId;
  }

  getModuleIfRequired(): ModuleType<M> | null {
    return this.moduleCache;
  }

  async load(): Promise<ModuleType<M>> {
    if (this.modulePromiseCache == null) {
      this.modulePromiseCache = RESOURCE_CONF[this.moduleId]
        .loader()
        .then((m) => {
          this.moduleCache = m as ModuleType<M>;
          return this.moduleCache;
        });
    }

    return await this.modulePromiseCache;
  }
}
"
`;

exports[`generatePastoriaArtifacts > empty project > generates router, js_resource, and server with empty configs 3`] = `
"/*
 * This file was generated by \`pastoria\`.
 * @generated-checksum <STRIPPED>
 * Do not modify this file directly. Instead, edit the template at server.ts.
 */

import express from 'express';

export const router = express.Router();
"
`;

exports[`generatePastoriaArtifacts > multiple routes > generates output with multiple page and server routes 1`] = `
"/*
 * This file was generated by \`pastoria\`.
 * @generated-checksum <STRIPPED>
 * Do not modify this file directly. Instead, edit the template at router.tsx.
 */

import {
  AnyPreloadedEntryPoint,
  EnvironmentProvider,
  relayClientEnvironment,
  RouterOps,
} from 'pastoria-runtime';
import { createRouter } from 'radix3';
import {
  AnchorHTMLAttributes,
  createContext,
  PropsWithChildren,
  StrictMode,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useState,
} from 'react';
import { preinit, preloadModule } from 'react-dom';
import {
  EntryPoint,
  EntryPointContainer,
  EntryPointProps,
  loadEntryPoint,
  RelayEnvironmentProvider,
  useEntryPointLoader,
} from 'react-relay/hooks';
import * as z from 'zod/v4-mini';
import {
  schema as about_EP_schema,
  entrypoint as about_EP_entrypoint,
  Queries as about_EP_Queries,
  EntryPoints as about_EP_EntryPoints,
} from './about_page.entrypoint';
import {
  schema as home_EP_schema,
  entrypoint as home_EP_entrypoint,
  Queries as home_EP_Queries,
  EntryPoints as home_EP_EntryPoints,
} from './home_page.entrypoint';

type RouterConf = typeof ROUTER_CONF;
const ROUTER_CONF = {
  '/about': {
    entrypoint: about_EP_entrypoint,
    schema: about_EP_schema,
  } as const,
  '/home': {
    entrypoint: home_EP_entrypoint,
    schema: home_EP_schema,
  } as const,
} as const;

export type RouteId = keyof RouterConf;
export type NavigationDirection = string | URL | ((nextUrl: URL) => void);

const ROUTE_MAPPING = {
  '/about': ROUTER_CONF['/about'],
  '/home': ROUTER_CONF['/home'],
};

const ROUTER = createRouter<RouterConf[keyof RouterConf]>({
  routes: ROUTE_MAPPING,
});

class RouterLocation {
  private constructor(
    readonly pathname: string,
    readonly searchParams: URLSearchParams,
    readonly method?: 'push' | 'replace' | 'popstate',
  ) {}

  href() {
    if (this.searchParams.size > 0) {
      return this.pathname + '?' + this.searchParams.toString();
    }

    return this.pathname;
  }

  route() {
    return ROUTER.lookup(this.pathname);
  }

  params() {
    const matchedRoute = this.route();
    const params = {
      ...matchedRoute?.params,
      ...Object.fromEntries(this.searchParams),
    };

    if (matchedRoute?.schema) {
      return matchedRoute.schema.parse(params);
    } else {
      return params;
    }
  }

  static parse(path: string, method?: 'push' | 'replace' | 'popstate') {
    if (path.startsWith('/')) {
      path = 'router:' + path;
    }

    try {
      const nextUrl = new URL(path);
      return new RouterLocation(nextUrl.pathname, nextUrl.searchParams, method);
    } catch (_e) {
      return new RouterLocation(path, new URLSearchParams(), method);
    }
  }
}

function useLocation(initialPath?: string) {
  const [location, setLocation] = useState((): RouterLocation => {
    return RouterLocation.parse(initialPath ?? window.location.href);
  });

  useEffect(() => {
    function listener(e: PopStateEvent) {
      setLocation(RouterLocation.parse(window.location.href, 'popstate'));
    }

    window.addEventListener('popstate', listener);
    return () => {
      window.removeEventListener('popstate', listener);
    };
  }, []);

  useEffect(() => {
    if (location.method === 'push') {
      window.history.pushState({}, '', location.href());
      window.scrollTo(0, 0);
    } else if (location.method === 'replace') {
      window.history.replaceState({}, '', location.href());
    }
  }, [location]);

  return [location, setLocation] as const;
}

export function router__hydrateStore(provider: EnvironmentProvider) {
  const env = provider.getEnvironment(null);
  if ('__router_ops' in window) {
    const ops = (window as any).__router_ops as RouterOps;
    for (const [op, payload] of ops) {
      env.commitPayload(op, payload);
    }
  }
}

export async function router__loadEntryPoint(
  provider: EnvironmentProvider,
  initialPath?: string,
) {
  if (!initialPath) initialPath = window.location.href;
  const initialLocation = RouterLocation.parse(initialPath);
  const initialRoute = initialLocation.route();
  if (!initialRoute) return null;

  await initialRoute.entrypoint?.root.load();
  return loadEntryPoint(provider, initialRoute.entrypoint, {
    params: initialLocation.params(),
  });
}

interface RouterContextValue {
  location: RouterLocation;
  setLocation: React.Dispatch<React.SetStateAction<RouterLocation>>;
}

const RouterContext = createContext<RouterContextValue>({
  location: RouterLocation.parse('/'),
  setLocation: () => {},
});

const REACT_REFRESH_SCRIPT = \`
import RefreshRuntime from 'http://localhost:3000/@react-refresh'
RefreshRuntime.injectIntoGlobalHook(window)
window.$RefreshReg$ = () => {}
window.$RefreshSig$ = () => (type) => type
window.__vite_plugin_react_preamble_installed__ = true\`;

export function router__createAppFromEntryPoint(
  initialEntryPoint: AnyPreloadedEntryPoint | null,
  provider: EnvironmentProvider,
  initialPath?: string,
) {
  const env = provider.getEnvironment(null);

  function RouterShell({
    preloadModules,
    preloadStylesheets,
    children,
  }: PropsWithChildren<{
    preloadModules?: string[];
    preloadStylesheets?: string[];
  }>) {
    for (const m of preloadModules ?? []) {
      preloadModule(m, { as: 'script' });
    }

    for (const s of preloadStylesheets ?? []) {
      preinit(s, { as: 'style' });
    }

    return (
      <StrictMode>
        <RelayEnvironmentProvider environment={env}>
          <html>
            <head>
              <meta charSet="utf-8" />
              <meta
                name="viewport"
                content="width=device-width, initial-scale=1"
              />

              {process.env.NODE_ENV !== 'production' && (
                <script
                  type="module"
                  dangerouslySetInnerHTML={{ __html: REACT_REFRESH_SCRIPT }}
                />
              )}
            </head>

            <body>{children}</body>
          </html>
        </RelayEnvironmentProvider>
      </StrictMode>
    );
  }

  function RouterCore() {
    const [location, setLocation] = useLocation(initialPath);
    const routerContextValue = useMemo(
      (): RouterContextValue => ({
        location,
        setLocation,
      }),
      [location, setLocation],
    );

    const [entryPointRef, loadEntryPointRef, _dispose] = useEntryPointLoader(
      provider,
      location.route()?.entrypoint,
    );

    useEffect(() => {
      loadEntryPointRef({ params: location.params() });
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [location]);

    const entryPoint = entryPointRef ?? initialEntryPoint;
    if (entryPoint == null) return null;

    return (
      <RouterContext value={routerContextValue}>
        <EntryPointContainer entryPointReference={entryPoint} props={{}} />
      </RouterContext>
    );
  }

  function RouterApp(props: {
    preloadModules?: string[];
    preloadStylesheets?: string[];
    App?: React.ComponentType<PropsWithChildren<{}>> | null;
  }) {
    return (
      <RouterShell
        preloadModules={props.preloadModules}
        preloadStylesheets={props.preloadStylesheets}
      >
        {props.App == null ? (
          <RouterCore />
        ) : (
          <props.App children={<RouterCore />} />
        )}
      </RouterShell>
    );
  }

  return RouterApp;
}

export async function createRouterApp() {
  const provider = relayClientEnvironment;

  router__hydrateStore(provider);
  const ep = await router__loadEntryPoint(provider);
  return router__createAppFromEntryPoint(ep, provider);
}

export function usePath() {
  const { location } = useContext(RouterContext);
  return location.pathname;
}

export function useRouteParams<R extends RouteId>(
  routeId: R,
): z.infer<RouterConf[R]['schema']> {
  const schema = ROUTER_CONF[routeId].schema;
  const { location } = useContext(RouterContext);

  return schema.parse(location.params()) as z.infer<RouterConf[R]['schema']>;
}

function router__createPathForRoute(
  routeId: RouteId,
  inputParams: Record<string, any>,
): string {
  const schema = ROUTER_CONF[routeId].schema;
  const params = schema.parse(inputParams);

  let pathname = routeId as string;
  const searchParams = new URLSearchParams();

  Object.entries(params).forEach(([key, value]) => {
    if (value != null) {
      const paramPattern = \`:\${key}\`;
      if (pathname.includes(paramPattern)) {
        pathname = pathname.replace(
          paramPattern,
          encodeURIComponent(String(value)),
        );
      } else {
        searchParams.set(key, String(value));
      }
    }
  });

  if (searchParams.size > 0) {
    return pathname + '?' + searchParams.toString();
  } else {
    return pathname;
  }
}

function router__evaluateNavigationDirection(nav: NavigationDirection) {
  let nextUrl: URL;
  if (typeof nav === 'string') {
    nextUrl = new URL(nav, window.location.origin);
  } else if (nav instanceof URL) {
    nextUrl = nav;
  } else {
    nextUrl = new URL(window.location.href);
    nav(nextUrl);
  }

  if (window.location.origin !== nextUrl.origin) {
    throw new Error('Cannot navigate to a different origin.');
  }

  if (nextUrl.searchParams.size > 0) {
    return nextUrl.pathname + '?' + nextUrl.searchParams.toString();
  } else {
    return nextUrl.pathname;
  }
}

export function useNavigation() {
  const { setLocation } = useContext(RouterContext);

  return useMemo(() => {
    function push(nav: NavigationDirection) {
      setLocation(
        RouterLocation.parse(router__evaluateNavigationDirection(nav), 'push'),
      );
    }

    function replace(nav: NavigationDirection) {
      setLocation(
        RouterLocation.parse(
          router__evaluateNavigationDirection(nav),
          'replace',
        ),
      );
    }

    function pushRoute<R extends RouteId>(
      routeId: R,
      params: z.input<RouterConf[R]['schema']>,
    ) {
      setLocation(
        RouterLocation.parse(
          router__createPathForRoute(routeId, params),
          'push',
        ),
      );
    }

    function replaceRoute<R extends RouteId>(
      routeId: R,
      params: z.input<RouterConf[R]['schema']>,
    ) {
      setLocation((prevLoc) =>
        RouterLocation.parse(
          router__createPathForRoute(routeId, {
            ...prevLoc.params(),
            ...params,
          }),
          'replace',
        ),
      );
    }

    return { push, replace, pushRoute, replaceRoute } as const;
  }, [setLocation]);
}

export function Link({
  href,
  target,
  onClick,
  ...props
}: AnchorHTMLAttributes<HTMLAnchorElement>) {
  const { push } = useNavigation();

  const handleClick = useCallback(
    (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {
      onClick?.(e);
      if (e.defaultPrevented || !href) return;

      // See https://github.com/remix-run/react-router/blob/main/packages/react-router/lib/dom/dom.ts#L34
      const shouldHandle =
        e.button === 0 &&
        (!target || target === '_self') &&
        !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);

      if (!shouldHandle) return;

      const destination = new URL(href, window.location.href);
      if (destination.origin !== window.location.origin) return;

      e.preventDefault();
      push(destination);
    },
    [push, href, target, onClick],
  );

  return <a {...props} href={href} target={target} onClick={handleClick} />;
}

export interface LinkProps<R extends RouteId>
  extends AnchorHTMLAttributes<HTMLAnchorElement> {
  route: R;
  params: z.input<RouterConf[R]['schema']>;
  href?: never;
}

export function RouteLink<R extends RouteId>({
  route,
  params,
  ...props
}: PropsWithChildren<LinkProps<R>>) {
  const href = useMemo(
    () => router__createPathForRoute(route, params).toString(),
    [params, route],
  );

  return <Link {...props} href={href} />;
}

export function listRoutes() {
  return Object.keys(ROUTE_MAPPING);
}

export function getSchemaForRoute<R extends RouteId>(
  routeId: R,
): RouterConf[R]['schema'] {
  return ROUTER_CONF[routeId].schema;
}

declare global {
  type PastoriaRouteName = '/about' | '/home';

  type PastoriaPageQueries = {
    ['/about']: about_EP_Queries;
    ['/home']: home_EP_Queries;
  };

  type PastoriaPageEntryPoints = {
    ['/about']: about_EP_EntryPoints;
    ['/home']: home_EP_EntryPoints;
  };

  type PastoriaPageProps<T extends PastoriaRouteName> = EntryPointProps<
    PastoriaPageQueries[T],
    PastoriaPageEntryPoints[T],
    {},
    {}
  >;
}
"
`;

exports[`generatePastoriaArtifacts > multiple routes > generates output with multiple page and server routes 2`] = `
"/*
 * This file was generated by \`pastoria\`.
 * @generated-checksum <STRIPPED>
 * Do not modify this file directly. Instead, edit the template at js_resource.ts.
 */

import type { JSResourceReference } from 'react-relay/hooks';

type ResourceConf = typeof RESOURCE_CONF;
const RESOURCE_CONF = {
  '#pastoria/about/page': {
    src: 'pastoria/about/page.tsx',
    loader: () => import('#pastoria/about/page').then((m) => m.default),
  },
  '#pastoria/home/page': {
    src: 'pastoria/home/page.tsx',
    loader: () => import('#pastoria/home/page').then((m) => m.default),
  },
} as const;

type ModuleId = keyof ResourceConf;
export type ModuleType<M extends ModuleId> = Awaited<
  ReturnType<ResourceConf[M]['loader']>
>;

export class JSResource<M extends ModuleId>
  implements JSResourceReference<ModuleType<M>>
{
  static srcOfModuleId(id: string): string | null {
    return RESOURCE_CONF[id as ModuleId].src;
  }

  private static readonly resourceCache = new Map<ModuleId, JSResource<any>>();
  static fromModuleId<M extends ModuleId>(moduleId: M) {
    if (JSResource.resourceCache.has(moduleId)) {
      return JSResource.resourceCache.get(moduleId)!;
    }

    const resource = new JSResource(moduleId);
    JSResource.resourceCache.set(moduleId, resource);
    return resource;
  }

  private constructor(private readonly moduleId: M) {}
  private modulePromiseCache: Promise<ModuleType<M>> | null = null;
  private moduleCache: ModuleType<M> | null = null;

  getModuleId(): string {
    return this.moduleId;
  }

  getModuleIfRequired(): ModuleType<M> | null {
    return this.moduleCache;
  }

  async load(): Promise<ModuleType<M>> {
    if (this.modulePromiseCache == null) {
      this.modulePromiseCache = RESOURCE_CONF[this.moduleId]
        .loader()
        .then((m) => {
          this.moduleCache = m as ModuleType<M>;
          return this.moduleCache;
        });
    }

    return await this.modulePromiseCache;
  }
}
"
`;

exports[`generatePastoriaArtifacts > multiple routes > generates output with multiple page and server routes 3`] = `
"/*
 * This file was generated by \`pastoria\`.
 * @generated-checksum <STRIPPED>
 * Do not modify this file directly. Instead, edit the template at server.ts.
 */

import express from 'express';
import { default as e0 } from '../../pastoria/api/health/route';
import { default as e1 } from '../../pastoria/api/greet/[name]/route';

export const router = express.Router();
router.use('/api/health', e0);
router.use('/api/greet/:name', e1);
"
`;

exports[`generatePastoriaArtifacts > server route > generates a server.ts with express route handler 1`] = `
"/*
 * This file was generated by \`pastoria\`.
 * @generated-checksum <STRIPPED>
 * Do not modify this file directly. Instead, edit the template at server.ts.
 */

import express from 'express';
import { default as e0 } from '../../pastoria/api/greet/[name]/route';

export const router = express.Router();
router.use('/api/greet/:name', e0);
"
`;

exports[`generatePastoriaArtifacts > simple page route > generates an entrypoint for a page.tsx with default export and no queries 1`] = `
"/*
 * This file was generated by \`pastoria\`.
 * @generated-checksum <STRIPPED>
 * Do not modify this file directly.
 */
import { EntryPoint } from 'react-relay/hooks';
import { z } from 'zod/v4-mini';
import { JSResource, ModuleType } from './js_resource';

const schema = z.object({});
const entrypoint: EntryPoint<
  ModuleType<'#pastoria/home/page'>,
  { params: Record<string, unknown> }
> = {
  root: JSResource.fromModuleId('#pastoria/home/page'),
  getPreloadProps({ params }) {
    const variables = schema.parse(params);
    return {
      queries: {},
      entryPoints: {},
    };
  },
};
type Queries = {};
type EntryPoints = {};

export { entrypoint, schema, type EntryPoints, type Queries };
"
`;
