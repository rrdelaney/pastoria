import ParcelWatcher, {getEventsSince, writeSnapshot} from '@parcel/watcher';
import tailwindcss from '@tailwindcss/vite';
import react from '@vitejs/plugin-react';
import {spawn} from 'node:child_process';
import {access, readFile} from 'node:fs/promises';
import path from 'node:path';
import {IndentationText, Project} from 'ts-morph';
import {
  build,
  InlineConfig,
  PluginOption,
  type BuildEnvironmentOptions,
  type Plugin,
} from 'vite';
import {cjsInterop} from 'vite-plugin-cjs-interop';
import {
  generatePastoriaArtifacts,
  generatePastoriaExports,
  PASTORIA_TAG_REGEX,
  PastoriaMetadata,
} from './generate.js';

interface PastoriaCapabilities {
  hasAppRoot: boolean;
  hasServerHandler: boolean;
}

const SNAPSHOT_PATH = '.pastoriainfo';

async function runCommand(command: string, args: string[]): Promise<void> {
  return new Promise((resolve, reject) => {
    const child = spawn(command, args, {
      cwd: process.cwd(),
      stdio: 'inherit', // Stream output to terminal
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        resolve();
      } else {
        reject(new Error(`Command failed with exit code ${code}`));
      }
    });

    child.on('error', reject);
  });
}

async function runGratsCompiler(): Promise<void> {
  const gratsPath = path.join(process.cwd(), 'node_modules', '.bin', 'grats');
  await runCommand(gratsPath, []);
}

async function runRelayCompiler(): Promise<void> {
  const relayPath = path.join(
    process.cwd(),
    'node_modules',
    '.bin',
    'relay-compiler',
  );
  await runCommand(relayPath, []);
}

function fileMatchesPastoriaTags(filePath: string, content: string): boolean {
  // Skip generated files
  if (filePath.includes('__generated__')) {
    return false;
  }
  return PASTORIA_TAG_REGEX.test(content);
}

function fileMatchesGratsTags(filePath: string, content: string): boolean {
  // Skip generated files
  if (filePath.includes('__generated__')) {
    return false;
  }
  // Match any Grats JSDoc tag
  return /@gql\w+/.test(content);
}

function fileMatchesRelayImports(filePath: string, content: string): boolean {
  // Skip generated files
  if (filePath.includes('__generated__')) {
    return false;
  }
  return (
    /import\s+.*\s+from\s+['"]react-relay['"]/.test(content) ||
    /import\s+.*\s+from\s+['"]relay-runtime['"]/.test(content)
  );
}

async function analyzeChangedFiles(
  events: Array<{type: string; path: string}>,
): Promise<{
  needsPastoriaExports: boolean;
  needsGratsCompiler: boolean;
  needsRelayCompiler: boolean;
  needsPastoriaArtifacts: boolean;
}> {
  let needsPastoriaExports = false;
  let needsGratsCompiler = false;
  let needsRelayCompiler = false;
  let needsPastoriaArtifacts = false;

  for (const event of events) {
    const filePath = event.path;

    // Skip non-TypeScript/TSX files
    if (!filePath.match(/\.(ts|tsx)$/)) {
      continue;
    }

    // For delete events, we can't read content, so assume it might affect all pipelines
    if (event.type === 'delete') {
      needsPastoriaExports = true;
      needsGratsCompiler = true;
      needsRelayCompiler = true;
      needsPastoriaArtifacts = true;
      continue;
    }

    // Read file content for create/update events
    try {
      const content = await readFile(filePath, 'utf-8');

      if (fileMatchesPastoriaTags(filePath, content)) {
        needsPastoriaExports = true;
        needsPastoriaArtifacts = true;
      }

      if (fileMatchesGratsTags(filePath, content)) {
        needsGratsCompiler = true;
        needsRelayCompiler = true; // Relay depends on Grats schema
      }

      if (fileMatchesRelayImports(filePath, content)) {
        needsRelayCompiler = true;
      }
    } catch {
      // If we can't read the file, assume it might affect all pipelines
      needsPastoriaExports = true;
      needsGratsCompiler = true;
      needsRelayCompiler = true;
      needsPastoriaArtifacts = true;
    }
  }

  return {
    needsPastoriaExports,
    needsGratsCompiler,
    needsRelayCompiler,
    needsPastoriaArtifacts,
  };
}

function generateClientEntry({hasAppRoot}: PastoriaCapabilities): string {
  const appImport = hasAppRoot
    ? `import {App} from '#genfiles/router/app_root';`
    : '';
  const appValue = hasAppRoot ? 'App' : 'null';

  return `// Generated by Pastoria.
import {createRouterApp} from '#genfiles/router/router';
${appImport}
import {hydrateRoot} from 'react-dom/client';

async function main() {
  const RouterApp = await createRouterApp();
  hydrateRoot(document, <RouterApp App={${appValue}} />);
}

main();
`;
}

function generateServerEntry({
  hasAppRoot,
  hasServerHandler,
}: PastoriaCapabilities): string {
  const appImport = hasAppRoot
    ? `import {App} from '#genfiles/router/app_root';`
    : '';
  const appValue = hasAppRoot ? 'App' : 'null';

  const serverHandlerImport = hasServerHandler
    ? `import {router as serverHandler} from '#genfiles/router/server_handler';`
    : '';
  const serverHandlerUse = hasServerHandler
    ? '  router.use(serverHandler)'
    : '';

  return `// Generated by Pastoria.
import {JSResource} from '#genfiles/router/js_resource';
import {
  listRoutes,
  router__createAppFromEntryPoint,
  router__loadEntryPoint,
} from '#genfiles/router/router';
import {getSchema} from '#genfiles/schema/schema';
import {Context} from '#genfiles/router/context';
${appImport}
${serverHandlerImport}
import express from 'express';
import {GraphQLSchema, specifiedDirectives} from 'graphql';
import {PastoriaConfig} from 'pastoria-config';
import {createRouterHandler} from 'pastoria-runtime/server';
import type {Manifest} from 'vite';

const schemaConfig = getSchema().toConfig();
const schema = new GraphQLSchema({
  ...schemaConfig,
  directives: [...specifiedDirectives, ...schemaConfig.directives],
});

export function createHandler(
  persistedQueries: Record<string, string>,
  config: Required<PastoriaConfig>,
  manifest?: Manifest,
) {
  const routeHandler = createRouterHandler(
    listRoutes(),
    JSResource.srcOfModuleId,
    router__loadEntryPoint,
    router__createAppFromEntryPoint,
    ${appValue},
    schema,
    (req) => Context.createFromRequest(req),
    persistedQueries,
    config,
    manifest,
  );

  const router = express.Router();
  router.use(routeHandler);
  ${serverHandlerUse}

  return router;
}
`;
}

async function executeBuildSteps(
  project: Project,
  needs: {
    needsPastoriaExports: boolean;
    needsGratsCompiler: boolean;
    needsRelayCompiler: boolean;
    needsPastoriaArtifacts: boolean;
  },
): Promise<boolean> {
  let rebuiltAnything = false;
  let cachedMetadata: PastoriaMetadata | undefined = undefined;

  if (needs.needsPastoriaExports) {
    console.log('Running Pastoria exports generation...');
    cachedMetadata = await generatePastoriaExports(project);
    rebuiltAnything = true;
  }

  if (needs.needsGratsCompiler) {
    console.log('Running Grats compiler...');
    await runGratsCompiler();
    rebuiltAnything = true;
  }

  if (needs.needsRelayCompiler) {
    console.log('Running Relay compiler...');
    await runRelayCompiler();
    rebuiltAnything = true;
  }

  if (needs.needsPastoriaArtifacts) {
    console.log('Running Pastoria artifacts generation...');
    await generatePastoriaArtifacts(project, cachedMetadata);
    rebuiltAnything = true;
  }

  return rebuiltAnything;
}

async function determineCapabilities(): Promise<PastoriaCapabilities> {
  const capabilities: PastoriaCapabilities = {
    hasAppRoot: false,
    hasServerHandler: false,
  };

  async function hasAppRoot() {
    try {
      await access('__generated__/router/app_root.ts');
      capabilities.hasAppRoot = true;
    } catch {}
  }

  async function hasServerHandler() {
    try {
      await access('__generated__/router/server_handler.ts');
      capabilities.hasServerHandler = true;
    } catch {}
  }

  await Promise.all([hasAppRoot(), hasServerHandler()]);
  return capabilities;
}

function pastoriaEntryPlugin(): Plugin {
  const clientEntryModuleId = 'virtual:pastoria-entry-client.tsx';
  const serverEntryModuleId = 'virtual:pastoria-entry-server.tsx';

  return {
    name: 'pastoria-entry',
    resolveId(id) {
      if (id === clientEntryModuleId) {
        return clientEntryModuleId; // Return without \0 prefix so React plugin can see .tsx extension
      } else if (id === serverEntryModuleId) {
        return serverEntryModuleId;
      }
    },
    async load(id) {
      const capabilities = await determineCapabilities();
      if (id === clientEntryModuleId) {
        return generateClientEntry(capabilities);
      } else if (id === serverEntryModuleId) {
        return generateServerEntry(capabilities);
      }
    },
  };
}

export const CLIENT_BUILD: BuildEnvironmentOptions = {
  outDir: 'dist/client',
  rollupOptions: {
    input: 'virtual:pastoria-entry-client.tsx',
  },
};

export const SERVER_BUILD: BuildEnvironmentOptions = {
  outDir: 'dist/server',
  ssr: true,
  rollupOptions: {
    input: 'virtual:pastoria-entry-server.tsx',
  },
};

export function createBuildConfig(
  buildEnv: BuildEnvironmentOptions,
): InlineConfig {
  return {
    appType: 'custom' as const,
    build: {
      ...buildEnv,
      assetsInlineLimit: 0,
      manifest: true,
      ssrManifest: true,
    },
    plugins: [
      pastoriaEntryPlugin(),
      tailwindcss() as PluginOption,
      react({
        babel: {
          plugins: [['babel-plugin-react-compiler', {}], 'relay'],
        },
      }),
      cjsInterop({
        dependencies: ['react-relay', 'react-relay/hooks', 'relay-runtime'],
      }),
    ],
    ssr: {
      noExternal: ['pastoria-runtime'],
    },
  };
}

async function createReleaseBuild() {
  await build({
    ...createBuildConfig(CLIENT_BUILD),
    configFile: false,
  });

  await build({
    ...createBuildConfig(SERVER_BUILD),
    configFile: false,
  });
}

function determineBuildStepsFromArgs(steps: string[]): {
  needsPastoriaExports: boolean;
  needsGratsCompiler: boolean;
  needsRelayCompiler: boolean;
  needsPastoriaArtifacts: boolean;
} {
  const validSteps = new Set(['schema', 'relay', 'router']);
  const needs = {
    needsPastoriaExports: false,
    needsGratsCompiler: false,
    needsRelayCompiler: false,
    needsPastoriaArtifacts: false,
  };

  for (const step of steps) {
    if (!validSteps.has(step)) {
      throw new Error(
        `Invalid build step: ${step}. Valid steps are: schema, relay, router`,
      );
    }

    switch (step) {
      case 'schema':
        needs.needsGratsCompiler = true;
        break;
      case 'relay':
        needs.needsRelayCompiler = true;
        break;
      case 'router':
        needs.needsPastoriaExports = true;
        needs.needsPastoriaArtifacts = true;
        break;
    }
  }

  return needs;
}

export async function createBuild(
  steps: string[],
  opts: {
    alwaysMake: boolean;
    release: boolean;
    watch?: boolean;
  },
) {
  if (opts.watch && opts.release) {
    throw new Error(
      'Cannot use --watch and --release together. Watch mode is for development only.',
    );
  }

  const project = new Project({
    tsConfigFilePath: path.join(process.cwd(), 'tsconfig.json'),
    manipulationSettings: {
      indentationText: IndentationText.TwoSpaces,
    },
  });

  const cwd = process.cwd();
  let needsPastoriaExports = opts.alwaysMake;
  let needsGratsCompiler = opts.alwaysMake;
  let needsRelayCompiler = opts.alwaysMake;
  let needsPastoriaArtifacts = opts.alwaysMake;

  // If specific steps are provided, override automatic inference
  if (steps.length > 0) {
    const stepsNeeds = determineBuildStepsFromArgs(steps);
    needsPastoriaExports = stepsNeeds.needsPastoriaExports;
    needsGratsCompiler = stepsNeeds.needsGratsCompiler;
    needsRelayCompiler = stepsNeeds.needsRelayCompiler;
    needsPastoriaArtifacts = stepsNeeds.needsPastoriaArtifacts;
  }
  // Use @parcel/watcher to get changes since last snapshot
  else if (!opts.alwaysMake) {
    try {
      // Check if snapshot exists - if not, do a full build
      await access(SNAPSHOT_PATH);

      // Get events since last snapshot
      const events = await getEventsSince(cwd, SNAPSHOT_PATH);

      if (events.length > 0) {
        // Analyze which files changed and determine what needs to be rebuilt
        const analysis = await analyzeChangedFiles(events);
        needsPastoriaExports = analysis.needsPastoriaExports;
        needsGratsCompiler = analysis.needsGratsCompiler;
        needsRelayCompiler =
          analysis.needsRelayCompiler || analysis.needsGratsCompiler;
        needsPastoriaArtifacts =
          analysis.needsPastoriaArtifacts || analysis.needsPastoriaExports;
      }
    } catch (err) {
      // No snapshot exists yet, or error reading it - do a full build
      needsPastoriaExports = true;
      needsGratsCompiler = true;
      needsRelayCompiler = true;
      needsPastoriaArtifacts = true;
    }
  }

  // Execute build pipeline conditionally
  await executeBuildSteps(project, {
    needsPastoriaExports,
    needsGratsCompiler,
    needsRelayCompiler,
    needsPastoriaArtifacts,
  });

  // Write snapshot for next incremental build
  await writeSnapshot(cwd, SNAPSHOT_PATH);

  if (opts.release) {
    await createReleaseBuild();
  }

  // Start watch mode if requested
  if (opts.watch) {
    console.log('Watching for changes...');

    const subscription = await ParcelWatcher.subscribe(
      cwd,
      async (err, events) => {
        if (err) {
          console.error('Watch error:', err);
          return;
        }

        // Analyze which files changed and determine what needs to be rebuilt
        const analysis = await analyzeChangedFiles(events);

        const rebuiltAnything = await executeBuildSteps(project, analysis);

        if (rebuiltAnything) {
          // Write snapshot after successful rebuild
          await writeSnapshot(cwd, SNAPSHOT_PATH);
          console.log('Rebuild complete. Watching for changes...');
        }
      },
    );

    // Keep the process running
    process.on('SIGINT', async () => {
      await subscription.unsubscribe();
      process.exit(0);
    });
  }
}
